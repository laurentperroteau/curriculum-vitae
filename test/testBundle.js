!function(n){function e(r){if(t[r])return t[r].exports;var i=t[r]={exports:{},id:r,loaded:!1};return n[r].call(i.exports,i,i.exports,e),i.loaded=!0,i.exports}var t={};return e.m=n,e.c=t,e.p="",e(0)}([function(n,e,t){t(93),mocha.setup("bdd"),t(59),t(92)},function(n,e){"use strict";var t=function(n){arguments.length<=1||void 0===arguments[1]?"green":arguments[1]};n.exports=t},function(n,e){n.exports=function(){var n=[];return n.toString=function(){for(var n=[],e=0;e<this.length;e++){var t=this[e];t[2]?n.push("@media "+t[2]+"{"+t[1]+"}"):n.push(t[1])}return n.join("")},n.i=function(e,t){"string"==typeof e&&(e=[[null,e,""]]);for(var r={},i=0;i<this.length;i++){var o=this[i][0];"number"==typeof o&&(r[o]=!0)}for(i=0;i<e.length;i++){var s=e[i];"number"==typeof s[0]&&r[s[0]]||(t&&!s[2]?s[2]=t:t&&(s[2]="("+s[2]+") and ("+t+")"),n.push(s))}},n}},function(n,e,t){function r(n,e){for(var t=0;t<n.length;t++){var r=n[t],i=p[r.id];if(i){i.refs++;for(var o=0;o<i.parts.length;o++)i.parts[o](r.parts[o]);for(;o<r.parts.length;o++)i.parts.push(l(r.parts[o],e))}else{for(var s=[],o=0;o<r.parts.length;o++)s.push(l(r.parts[o],e));p[r.id]={id:r.id,refs:1,parts:s}}}}function i(n){for(var e=[],t={},r=0;r<n.length;r++){var i=n[r],o=i[0],s=i[1],a=i[2],u=i[3],l={css:s,media:a,sourceMap:u};t[o]?t[o].parts.push(l):e.push(t[o]={id:o,parts:[l]})}return e}function o(n,e){var t=m(),r=y[y.length-1];if("top"===n.insertAt)r?r.nextSibling?t.insertBefore(e,r.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),y.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function s(n){n.parentNode.removeChild(n);var e=y.indexOf(n);e>=0&&y.splice(e,1)}function a(n){var e=document.createElement("style");return e.type="text/css",o(n,e),e}function u(n){var e=document.createElement("link");return e.rel="stylesheet",o(n,e),e}function l(n,e){var t,r,i;if(e.singleton){var o=v++;t=b||(b=a(e)),r=f.bind(null,t,o,!1),i=f.bind(null,t,o,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=u(e),r=h.bind(null,t),i=function(){s(t),t.href&&URL.revokeObjectURL(t.href)}):(t=a(e),r=c.bind(null,t),i=function(){s(t)});return r(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;r(n=e)}else i()}}function f(n,e,t,r){var i=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=w(e,i);else{var o=document.createTextNode(i),s=n.childNodes;s[e]&&n.removeChild(s[e]),s.length?n.insertBefore(o,s[e]):n.appendChild(o)}}function c(n,e){var t=e.css,r=e.media;if(r&&n.setAttribute("media",r),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function h(n,e){var t=e.css,r=e.sourceMap;r&&(t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var i=new Blob([t],{type:"text/css"}),o=n.href;n.href=URL.createObjectURL(i),o&&URL.revokeObjectURL(o)}var p={},d=function(n){var e;return function(){return"undefined"==typeof e&&(e=n.apply(this,arguments)),e}},g=d(function(){return/msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase())}),m=d(function(){return document.head||document.getElementsByTagName("head")[0]}),b=null,v=0,y=[];n.exports=function(n,e){e=e||{},"undefined"==typeof e.singleton&&(e.singleton=g()),"undefined"==typeof e.insertAt&&(e.insertAt="bottom");var t=i(n);return r(t,e),function(n){for(var o=[],s=0;s<t.length;s++){var a=t[s],u=p[a.id];u.refs--,o.push(u)}if(n){var l=i(n);r(l,e)}for(var s=0;s<o.length;s++){var u=o[s];if(0===u.refs){for(var f=0;f<u.parts.length;f++)u.parts[f]();delete p[u.id]}}}};var w=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e,t){var r=n.__flags||(n.__flags=Object.create(null));return 3!==arguments.length?r[e]:void(r[e]=t)}},function(n,e,t){var r,i,o;!function(t,s){"use strict";i=[e],r=s,o="function"==typeof r?r.apply(e,i):r,!(void 0!==o&&(n.exports=o));var a={};t.PubSub=a,s(a)}("object"==typeof window&&window||this,function(n){"use strict";function e(n){var e;for(e in n)if(n.hasOwnProperty(e))return!0;return!1}function t(n){return function(){throw n}}function r(n,e,r){try{n(e,r)}catch(i){setTimeout(t(i),0)}}function i(n,e,t){n(e,t)}function o(n,e,t,o){var s,a=l[e],u=o?i:r;if(l.hasOwnProperty(e))for(s in a)a.hasOwnProperty(s)&&u(a[s],n,t)}function s(n,e,t){return function(){var r=String(n),i=r.lastIndexOf(".");for(o(n,n,e,t);-1!==i;)r=r.substr(0,i),i=r.lastIndexOf("."),o(n,r,e,t)}}function a(n){for(var t=String(n),r=Boolean(l.hasOwnProperty(t)&&e(l[t])),i=t.lastIndexOf(".");!r&&-1!==i;)t=t.substr(0,i),i=t.lastIndexOf("."),r=Boolean(l.hasOwnProperty(t)&&e(l[t]));return r}function u(n,e,t,r){var i=s(n,e,r),o=a(n);return o?(t===!0?i():setTimeout(i,0),!0):!1}var l={},f=-1;n.publish=function(e,t){return u(e,t,!1,n.immediateExceptions)},n.publishSync=function(e,t){return u(e,t,!0,n.immediateExceptions)},n.subscribe=function(n,e){if("function"!=typeof e)return!1;l.hasOwnProperty(n)||(l[n]={});var t="uid_"+String(++f);return l[n][t]=e,t},n.clearAllSubscriptions=function(){l={}},n.clearSubscriptions=function(n){var e;for(e in l)l.hasOwnProperty(e)&&0===e.indexOf(n)&&delete l[e]},n.unsubscribe=function(n){var e,t,r,i="string"==typeof n&&l.hasOwnProperty(n),o=!i&&"string"==typeof n,s="function"==typeof n,a=!1;if(i)return void delete l[n];for(e in l)if(l.hasOwnProperty(e)){if(t=l[e],o&&t[n]){delete t[n],a=n;break}if(s)for(r in t)t.hasOwnProperty(r)&&t[r]===n&&(delete t[r],a=!0)}return a}})},function(n,e){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var t=function(n,e){var t=new XMLHttpRequest,r=Promise.defer();return t.onreadystatechange=function(){4===t.readyState&&(200===t.status?e?r.resolve(JSON.parse(t.responseText)):r.resolve(t.responseText):r.reject(t.responseText))},t.open("GET",n),t.send(),r.promise};e["default"]=t},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{"default":n}}function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),s=t(1),a=(r(s),t(14)),u=r(a),l=t(12);l.configure({prefix:"my",templateDelimiters:["{{","}}"]});var f=function(){function n(e){i(this,n),this.sName=e,this.oData=void 0,this.nComponent=null}return o(n,[{key:"setData",value:function(n){this.oData=n}},{key:"initTemplate",value:function(){var n=this.sName+"/"+this.sName,e=t(36)("./"+n+".html");t(35)("./"+n+".css"),null===this.nComponent&&(this.nComponent=document.getElementById((0,u["default"])("js "+this.sName)),""!=e&&(this.nComponent.innerHTML=e,l.bind(this.nComponent,this.oData)))}}]),n}();e["default"]=f},function(n,e){n.exports={includeStack:!1,showDiff:!0,truncateThreshold:40}},function(n,e,t){var r,i;(function(){function t(n,e,t,r){return new o(n,e,t,r)}function o(n,e,t,r){this.options=r||{},this.options.adapters=this.options.adapters||{},this.obj=n,this.keypath=e,this.callback=t,this.objectPath=[],this.update=this.update.bind(this),this.parse(),s(this.target=this.realize())&&this.set(!0,this.key,this.target,this.callback)}function s(n){return"object"==typeof n&&null!==n}function a(n){throw new Error("[sightglass] "+n)}t.adapters={},o.tokenize=function(n,e,t){var r,i,o=[],s={i:t,path:""};for(r=0;r<n.length;r++)i=n.charAt(r),~e.indexOf(i)?(o.push(s),s={i:i,path:""}):s.path+=i;return o.push(s),o},o.prototype.parse=function(){var n,e,r=this.interfaces();r.length||a("Must define at least one adapter interface."),~r.indexOf(this.keypath[0])?(n=this.keypath[0],e=this.keypath.substr(1)):("undefined"==typeof(n=this.options.root||t.root)&&a("Must define a default root adapter."),e=this.keypath),this.tokens=o.tokenize(e,r,n),this.key=this.tokens.pop()},o.prototype.realize=function(){var n,e=this.obj,t=!1;return this.tokens.forEach(function(r,i){s(e)?("undefined"!=typeof this.objectPath[i]?e!==(n=this.objectPath[i])&&(this.set(!1,r,n,this.update),this.set(!0,r,e,this.update),this.objectPath[i]=e):(this.set(!0,r,e,this.update),this.objectPath[i]=e),e=this.get(r,e)):(t===!1&&(t=i),(n=this.objectPath[i])&&this.set(!1,r,n,this.update))},this),t!==!1&&this.objectPath.splice(t),e},o.prototype.update=function(){var n,e;(n=this.realize())!==this.target&&(s(this.target)&&this.set(!1,this.key,this.target,this.callback),s(n)&&this.set(!0,this.key,n,this.callback),e=this.value(),this.target=n,this.value()!==e&&this.callback())},o.prototype.value=function(){return s(this.target)?this.get(this.key,this.target):void 0},o.prototype.setValue=function(n){s(this.target)&&this.adapter(this.key).set(this.target,this.key.path,n)},o.prototype.get=function(n,e){return this.adapter(n).get(e,n.path)},o.prototype.set=function(n,e,t,r){var i=n?"observe":"unobserve";this.adapter(e)[i](t,e.path,r)},o.prototype.interfaces=function(){var n=Object.keys(this.options.adapters);return Object.keys(t.adapters).forEach(function(e){~n.indexOf(e)||n.push(e)}),n},o.prototype.adapter=function(n){return this.options.adapters[n.i]||t.adapters[n.i]},o.prototype.unobserve=function(){var n;this.tokens.forEach(function(e,t){(n=this.objectPath[t])&&this.set(!1,e,n,this.update)},this),s(this.target)&&this.set(!1,this.key,this.target,this.callback)},"undefined"!=typeof n&&n.exports?n.exports=t:(r=[],i=function(){return this.sightglass=t}.apply(e,r),!(void 0!==i&&(n.exports=i)))}).call(this)},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children=[],n.webpackPolyfill=1),n}},function(n,e){n.exports='<div class=app> <div class=app__bar> <div class=app__bar__top> {{ fileName }} </div> <div> <ul class="list list--inline"> <li>File</li> <li>Edit</li> <li>Selection</li> <li>Find</li> <li>View</li> <li>Goto</li> <li>Tools</li> <li>Project</li> <li>Preferences</li> <li>Help</li> </ul> </div> </div> <div class=app__main> <div id=jsTree class=tree></div> <div class=app__main__content> <div class=editor-ctn> <div id=jsTab class=tab></div> <div id=jsEditor class=editor></div> </div> </div> </div> </div>'},function(n,e,t){var r,i;(function(n){(function(){var o,s,a,u,l=function(n,e){return function(){return n.apply(e,arguments)}},f=[].slice,c={}.hasOwnProperty,h=function(n,e){function t(){this.constructor=n}for(var r in e)c.call(e,r)&&(n[r]=e[r]);return t.prototype=e.prototype,n.prototype=new t,n.__super__=e.prototype,n},p=[].indexOf||function(n){for(var e=0,t=this.length;t>e;e++)if(e in this&&this[e]===n)return e;return-1};o={options:["prefix","templateDelimiters","rootInterface","preloadData","handler"],extensions:["binders","formatters","components","adapters"],"public":{binders:{},components:{},formatters:{},adapters:{},prefix:"rv",templateDelimiters:["{","}"],rootInterface:".",preloadData:!0,handler:function(n,e,t){return this.call(n,e,t.view.models)},configure:function(n){var e,t,r,i;null==n&&(n={});for(r in n)if(i=n[r],"binders"===r||"components"===r||"formatters"===r||"adapters"===r)for(t in i)e=i[t],o[r][t]=e;else o["public"][r]=i},bind:function(n,e,t){var r;return null==e&&(e={}),null==t&&(t={}),r=new o.View(n,e,t),r.bind(),r},init:function(n,e,t){var r,i;return null==t&&(t={}),null==e&&(e=document.createElement("div")),n=o["public"].components[n],e.innerHTML=n.template.call(this,e),r=n.initialize.call(this,e,t),i=new o.View(e,r),i.bind(),i}}},window.jQuery||window.$?(u="on"in jQuery.prototype?["on","off"]:["bind","unbind"],s=u[0],a=u[1],o.Util={bindEvent:function(n,e,t){return jQuery(n)[s](e,t)},unbindEvent:function(n,e,t){return jQuery(n)[a](e,t)},getInputValue:function(n){var e;return e=jQuery(n),"checkbox"===e.attr("type")?e.is(":checked"):e.val()}}):o.Util={bindEvent:function(){return"addEventListener"in window?function(n,e,t){return n.addEventListener(e,t,!1)}:function(n,e,t){return n.attachEvent("on"+e,t)}}(),unbindEvent:function(){return"removeEventListener"in window?function(n,e,t){return n.removeEventListener(e,t,!1)}:function(n,e,t){return n.detachEvent("on"+e,t)}}(),getInputValue:function(n){var e,t,r,i;if("checkbox"===n.type)return n.checked;if("select-multiple"===n.type){for(i=[],t=0,r=n.length;r>t;t++)e=n[t],e.selected&&i.push(e.value);return i}return n.value}},o.TypeParser=function(){function n(){}return n.types={primitive:0,keypath:1},n.parse=function(n){return/^'.*'$|^".*"$/.test(n)?{type:this.types.primitive,value:n.slice(1,-1)}:"true"===n?{type:this.types.primitive,value:!0}:"false"===n?{type:this.types.primitive,value:!1}:"null"===n?{type:this.types.primitive,value:null}:"undefined"===n?{type:this.types.primitive,value:void 0}:isNaN(Number(n))===!1?{type:this.types.primitive,value:Number(n)}:{type:this.types.keypath,value:n}},n}(),o.TextTemplateParser=function(){function n(){}return n.types={text:0,binding:1},n.parse=function(n,e){var t,r,i,o,s,a,u;for(a=[],o=n.length,t=0,r=0;o>r;){if(t=n.indexOf(e[0],r),0>t){a.push({type:this.types.text,value:n.slice(r)});break}if(t>0&&t>r&&a.push({type:this.types.text,value:n.slice(r,t)}),r=t+e[0].length,t=n.indexOf(e[1],r),0>t){s=n.slice(r-e[1].length),i=a[a.length-1],(null!=i?i.type:void 0)===this.types.text?i.value+=s:a.push({type:this.types.text,value:s});break}u=n.slice(r,t).trim(),a.push({type:this.types.binding,value:u}),r=t+e[1].length}return a},n}(),o.View=function(){function n(n,e,t){var r,i,s,a,u,f,c,h,p,d,g,m,b;for(this.els=n,this.models=e,null==t&&(t={}),this.update=l(this.update,this),this.publish=l(this.publish,this),this.sync=l(this.sync,this),this.unbind=l(this.unbind,this),this.bind=l(this.bind,this),this.select=l(this.select,this),this.traverse=l(this.traverse,this),this.build=l(this.build,this),this.buildBinding=l(this.buildBinding,this),this.bindingRegExp=l(this.bindingRegExp,this),this.options=l(this.options,this),this.els.jquery||this.els instanceof Array||(this.els=[this.els]),p=o.extensions,u=0,c=p.length;c>u;u++){if(i=p[u],this[i]={},t[i]){d=t[i];for(r in d)s=d[r],this[i][r]=s}g=o["public"][i];for(r in g)s=g[r],null==(a=this[i])[r]&&(a[r]=s)}for(m=o.options,f=0,h=m.length;h>f;f++)i=m[f],this[i]=null!=(b=t[i])?b:o["public"][i];this.build()}return n.prototype.options=function(){var n,e,t,r,i;for(e={},i=o.extensions.concat(o.options),t=0,r=i.length;r>t;t++)n=i[t],e[n]=this[n];return e},n.prototype.bindingRegExp=function(){return new RegExp("^"+this.prefix+"-")},n.prototype.buildBinding=function(n,e,t,r){var i,s,a,u,l,f,c;return l={},c=function(){var n,e,t,i;for(t=r.split("|"),i=[],n=0,e=t.length;e>n;n++)f=t[n],i.push(f.trim());return i}(),i=function(){var n,e,t,r;for(t=c.shift().split("<"),r=[],n=0,e=t.length;e>n;n++)s=t[n],r.push(s.trim());return r}(),u=i.shift(),l.formatters=c,(a=i.shift())&&(l.dependencies=a.split(/\s+/)),this.bindings.push(new o[n](this,e,t,u,l))},n.prototype.build=function(){var n,e,t,r,i;for(this.bindings=[],e=function(n){return function(t){var r,i,s,a,u,l,f,c,h,p,d,g,m,b;if(3===t.nodeType){if(u=o.TextTemplateParser,(s=n.templateDelimiters)&&(c=u.parse(t.data,s)).length&&(1!==c.length||c[0].type!==u.types.text)){for(h=0,d=c.length;d>h;h++)f=c[h],l=document.createTextNode(f.value),t.parentNode.insertBefore(l,t),1===f.type&&n.buildBinding("TextBinding",l,null,f.value);t.parentNode.removeChild(t)}}else 1===t.nodeType&&(r=n.traverse(t));if(!r){for(m=function(){var n,e,r,i;for(r=t.childNodes,i=[],n=0,e=r.length;e>n;n++)a=r[n],i.push(a);return i}(),b=[],p=0,g=m.length;g>p;p++)i=m[p],b.push(e(i));return b}}}(this),i=this.els,t=0,r=i.length;r>t;t++)n=i[t],e(n);this.bindings.sort(function(n,e){var t,r;return((null!=(t=e.binder)?t.priority:void 0)||0)-((null!=(r=n.binder)?r.priority:void 0)||0)})},n.prototype.traverse=function(n){var e,t,r,i,s,a,u,l,f,c,h,p,d,g,m,b;for(i=this.bindingRegExp(),s="SCRIPT"===n.nodeName||"STYLE"===n.nodeName,g=n.attributes,c=0,p=g.length;p>c;c++)if(e=g[c],i.test(e.name)){if(l=e.name.replace(i,""),!(r=this.binders[l])){m=this.binders;for(a in m)f=m[a],"*"!==a&&-1!==a.indexOf("*")&&(u=new RegExp("^"+a.replace(/\*/g,".+")+"$"),u.test(l)&&(r=f))}r||(r=this.binders["*"]),r.block&&(s=!0,t=[e])}for(b=t||n.attributes,h=0,d=b.length;d>h;h++)e=b[h],i.test(e.name)&&(l=e.name.replace(i,""),this.buildBinding("Binding",n,l,e.value));return s||(l=n.nodeName.toLowerCase(),this.components[l]&&!n._bound&&(this.bindings.push(new o.ComponentBinding(this,n,l)),s=!0)),s},n.prototype.select=function(n){var e,t,r,i,o;for(i=this.bindings,o=[],t=0,r=i.length;r>t;t++)e=i[t],n(e)&&o.push(e);return o},n.prototype.bind=function(){var n,e,t,r,i;for(r=this.bindings,i=[],e=0,t=r.length;t>e;e++)n=r[e],i.push(n.bind());return i},n.prototype.unbind=function(){var n,e,t,r,i;for(r=this.bindings,i=[],e=0,t=r.length;t>e;e++)n=r[e],i.push(n.unbind());return i},n.prototype.sync=function(){var n,e,t,r,i;for(r=this.bindings,i=[],e=0,t=r.length;t>e;e++)n=r[e],i.push("function"==typeof n.sync?n.sync():void 0);return i},n.prototype.publish=function(){var n,e,t,r,i;for(r=this.select(function(n){var e;return null!=(e=n.binder)?e.publishes:void 0}),i=[],e=0,t=r.length;t>e;e++)n=r[e],i.push(n.publish());return i},n.prototype.update=function(n){var e,t,r,i,o,s,a;null==n&&(n={});for(t in n)r=n[t],this.models[t]=r;for(s=this.bindings,a=[],i=0,o=s.length;o>i;i++)e=s[i],a.push("function"==typeof e.update?e.update(n):void 0);return a},n}(),o.Binding=function(){function n(n,e,t,r,i){this.view=n,this.el=e,this.type=t,this.keypath=r,this.options=null!=i?i:{},this.getValue=l(this.getValue,this),this.update=l(this.update,this),this.unbind=l(this.unbind,this),this.bind=l(this.bind,this),this.publish=l(this.publish,this),this.sync=l(this.sync,this),this.set=l(this.set,this),this.eventHandler=l(this.eventHandler,this),this.formattedValue=l(this.formattedValue,this),this.parseTarget=l(this.parseTarget,this),this.observe=l(this.observe,this),this.setBinder=l(this.setBinder,this),this.formatters=this.options.formatters||[],this.dependencies=[],this.formatterObservers={},this.model=void 0,this.setBinder()}return n.prototype.setBinder=function(){var n,e,t,r;if(!(this.binder=this.view.binders[this.type])){r=this.view.binders;for(n in r)t=r[n],"*"!==n&&-1!==n.indexOf("*")&&(e=new RegExp("^"+n.replace(/\*/g,".+")+"$"),e.test(this.type)&&(this.binder=t,this.args=new RegExp("^"+n.replace(/\*/g,"(.+)")+"$").exec(this.type),this.args.shift()))}return this.binder||(this.binder=this.view.binders["*"]),this.binder instanceof Function?this.binder={routine:this.binder}:void 0},n.prototype.observe=function(n,e,t){return o.sightglass(n,e,t,{root:this.view.rootInterface,adapters:this.view.adapters})},n.prototype.parseTarget=function(){var n;return n=o.TypeParser.parse(this.keypath),0===n.type?this.value=n.value:(this.observer=this.observe(this.view.models,this.keypath,this.sync),this.model=this.observer.target)},n.prototype.formattedValue=function(n){var e,t,r,i,s,a,u,l,c,h,p,d,g,m;for(m=this.formatters,i=h=0,d=m.length;d>h;i=++h){for(s=m[i],r=s.match(/[^\s']+|'([^']|'[^\s])*'|"([^"]|"[^\s])*"/g),a=r.shift(),s=this.view.formatters[a],r=function(){var n,e,i;for(i=[],n=0,e=r.length;e>n;n++)t=r[n],i.push(o.TypeParser.parse(t));return i}(),l=[],e=p=0,g=r.length;g>p;e=++p)t=r[e],l.push(0===t.type?t.value:((c=this.formatterObservers)[i]||(c[i]={}),(u=this.formatterObservers[i][e])?void 0:(u=this.observe(this.view.models,t.value,this.sync),this.formatterObservers[i][e]=u),u.value()));(null!=s?s.read:void 0)instanceof Function?n=s.read.apply(s,[n].concat(f.call(l))):s instanceof Function&&(n=s.apply(null,[n].concat(f.call(l))))}return n},n.prototype.eventHandler=function(n){var e,t;return t=(e=this).view.handler,function(r){return t.call(n,this,r,e)}},n.prototype.set=function(n){var e;return n=n instanceof Function&&!this.binder["function"]?this.formattedValue(n.call(this.model)):this.formattedValue(n),null!=(e=this.binder.routine)?e.call(this,this.el,n):void 0},n.prototype.sync=function(){var n,e;return this.set(function(){var t,r,i,o,s,a,u;if(this.observer){if(this.model!==this.observer.target){for(s=this.dependencies,t=0,i=s.length;i>t;t++)e=s[t],e.unobserve();if(this.dependencies=[],null!=(this.model=this.observer.target)&&(null!=(a=this.options.dependencies)?a.length:void 0))for(u=this.options.dependencies,r=0,o=u.length;o>r;r++)n=u[r],e=this.observe(this.model,n,this.sync),this.dependencies.push(e)}return this.observer.value()}return this.value}.call(this))},n.prototype.publish=function(){var n,e,t,r,i,o,s,a,u;if(this.observer){for(r=this.getValue(this.el),s=this.formatters.slice(0).reverse(),i=0,o=s.length;o>i;i++)e=s[i],n=e.split(/\s+/),t=n.shift(),(null!=(a=this.view.formatters[t])?a.publish:void 0)&&(r=(u=this.view.formatters[t]).publish.apply(u,[r].concat(f.call(n))));return this.observer.setValue(r)}},n.prototype.bind=function(){var n,e,t,r,i,o,s;if(this.parseTarget(),null!=(i=this.binder.bind)&&i.call(this,this.el),null!=this.model&&(null!=(o=this.options.dependencies)?o.length:void 0))for(s=this.options.dependencies,t=0,r=s.length;r>t;t++)n=s[t],e=this.observe(this.model,n,this.sync),this.dependencies.push(e);return this.view.preloadData?this.sync():void 0},n.prototype.unbind=function(){var n,e,t,r,i,o,s,a,u,l;for(null!=(s=this.binder.unbind)&&s.call(this,this.el),null!=(a=this.observer)&&a.unobserve(),u=this.dependencies,i=0,o=u.length;o>i;i++)r=u[i],r.unobserve();this.dependencies=[],l=this.formatterObservers;for(t in l){e=l[t];for(n in e)r=e[n],r.unobserve()}return this.formatterObservers={}},n.prototype.update=function(n){var e,t;return null==n&&(n={}),this.model=null!=(e=this.observer)?e.target:void 0,null!=(t=this.binder.update)?t.call(this,n):void 0},n.prototype.getValue=function(n){return this.binder&&null!=this.binder.getValue?this.binder.getValue.call(this,n):o.Util.getInputValue(n)},n}(),o.ComponentBinding=function(n){function e(n,e,t){var r,i,o,s,a,u,f;for(this.view=n,this.el=e,this.type=t,this.unbind=l(this.unbind,this),this.bind=l(this.bind,this),this.locals=l(this.locals,this),this.component=this.view.components[this.type],this["static"]={},this.observers={},this.upstreamObservers={},i=n.bindingRegExp(),u=this.el.attributes||[],s=0,a=u.length;a>s;s++)r=u[s],i.test(r.name)||(o=this.camelCase(r.name),p.call(null!=(f=this.component["static"])?f:[],o)>=0?this["static"][o]=r.value:this.observers[o]=r.value)}return h(e,n),e.prototype.sync=function(){},e.prototype.update=function(){},e.prototype.publish=function(){},e.prototype.locals=function(){var n,e,t,r,i,o;t={},i=this["static"];for(n in i)r=i[n],t[n]=r;o=this.observers;for(n in o)e=o[n],t[n]=e.value();return t},e.prototype.camelCase=function(n){return n.replace(/-([a-z])/g,function(n){return n[1].toUpperCase()})},e.prototype.bind=function(){var n,e,t,r,i,s,a,u,l,f,c,h,p,d,g,m,b,v,y,w,x;if(!this.bound){d=this.observers;for(e in d)t=d[e],this.observers[e]=this.observe(this.view.models,t,function(n){return function(e){return function(){return n.componentView.models[e]=n.observers[e].value()}}}(this).call(this,e));this.bound=!0}if(null!=this.componentView)return this.componentView.bind();for(this.el.innerHTML=this.component.template.call(this),a=this.component.initialize.call(this,this.el,this.locals()),this.el._bound=!0,s={},g=o.extensions,f=0,h=g.length;h>f;f++){if(i=g[f],s[i]={},this.component[i]){m=this.component[i];for(n in m)u=m[n],s[i][n]=u}b=this.view[i];for(n in b)u=b[n],null==(l=s[i])[n]&&(l[n]=u)}for(v=o.options,c=0,p=v.length;p>c;c++)i=v[c],s[i]=null!=(y=this.component[i])?y:this.view[i];this.componentView=new o.View(this.el,a,s),this.componentView.bind(),w=this.observers,x=[];for(e in w)r=w[e],x.push(this.upstreamObservers[e]=this.observe(this.componentView.models,e,function(n){return function(e,t){return function(){return t.setValue(n.componentView.models[e])}}}(this).call(this,e,r)));return x},e.prototype.unbind=function(){var n,e,t,r,i;t=this.upstreamObservers;for(n in t)e=t[n],e.unobserve();r=this.observers;for(n in r)e=r[n],e.unobserve();return null!=(i=this.componentView)?i.unbind.call(this):void 0},e}(o.Binding),o.TextBinding=function(n){function e(n,e,t,r,i){this.view=n,this.el=e,this.type=t,this.keypath=r,this.options=null!=i?i:{},this.sync=l(this.sync,this),this.formatters=this.options.formatters||[],this.dependencies=[],this.formatterObservers={}}return h(e,n),e.prototype.binder={routine:function(n,e){return n.data=null!=e?e:""}},e.prototype.sync=function(){return e.__super__.sync.apply(this,arguments)},e}(o.Binding),o["public"].binders.text=function(n,e){return null!=n.textContent?n.textContent=null!=e?e:"":n.innerText=null!=e?e:""},o["public"].binders.html=function(n,e){return n.innerHTML=null!=e?e:""},o["public"].binders.show=function(n,e){return n.style.display=e?"":"none"},o["public"].binders.hide=function(n,e){return n.style.display=e?"none":""},o["public"].binders.enabled=function(n,e){return n.disabled=!e},o["public"].binders.disabled=function(n,e){return n.disabled=!!e},o["public"].binders.checked={publishes:!0,priority:2e3,bind:function(n){return o.Util.bindEvent(n,"change",this.publish)},unbind:function(n){return o.Util.unbindEvent(n,"change",this.publish)},routine:function(n,e){var t;return"radio"===n.type?n.checked=(null!=(t=n.value)?t.toString():void 0)===(null!=e?e.toString():void 0):n.checked=!!e}},o["public"].binders.unchecked={publishes:!0,priority:2e3,bind:function(n){return o.Util.bindEvent(n,"change",this.publish)},unbind:function(n){return o.Util.unbindEvent(n,"change",this.publish)},routine:function(n,e){var t;return"radio"===n.type?n.checked=(null!=(t=n.value)?t.toString():void 0)!==(null!=e?e.toString():void 0):n.checked=!e}},o["public"].binders.value={publishes:!0,priority:3e3,bind:function(n){return"INPUT"!==n.tagName||"radio"!==n.type?(this.event="SELECT"===n.tagName?"change":"input",o.Util.bindEvent(n,this.event,this.publish)):void 0},unbind:function(n){return"INPUT"!==n.tagName||"radio"!==n.type?o.Util.unbindEvent(n,this.event,this.publish):void 0},routine:function(n,e){var t,r,i,o,s,a,u;if("INPUT"===n.tagName&&"radio"===n.type)return n.setAttribute("value",e);if(null!=window.jQuery){if(n=jQuery(n),(null!=e?e.toString():void 0)!==(null!=(o=n.val())?o.toString():void 0))return n.val(null!=e?e:"")}else if("select-multiple"===n.type){if(null!=e){for(u=[],r=0,i=n.length;i>r;r++)t=n[r],u.push(t.selected=(s=t.value,p.call(e,s)>=0));return u}}else if((null!=e?e.toString():void 0)!==(null!=(a=n.value)?a.toString():void 0))return n.value=null!=e?e:""}},o["public"].binders["if"]={block:!0,priority:4e3,bind:function(n){var e,t;return null==this.marker?(e=[this.view.prefix,this.type].join("-").replace("--","-"),t=n.getAttribute(e),this.marker=document.createComment(" rivets: "+this.type+" "+t+" "),this.bound=!1,n.removeAttribute(e),n.parentNode.insertBefore(this.marker,n),n.parentNode.removeChild(n)):void 0},unbind:function(){var n;return null!=(n=this.nested)?n.unbind():void 0},routine:function(n,e){var t,r,i,s;if(!!e==!this.bound){if(e){i={},s=this.view.models;for(t in s)r=s[t],i[t]=r;return(this.nested||(this.nested=new o.View(n,i,this.view.options()))).bind(),this.marker.parentNode.insertBefore(n,this.marker.nextSibling),this.bound=!0}return n.parentNode.removeChild(n),this.nested.unbind(),this.bound=!1}},update:function(n){var e;return null!=(e=this.nested)?e.update(n):void 0}},o["public"].binders.unless={block:!0,priority:4e3,bind:function(n){return o["public"].binders["if"].bind.call(this,n)},unbind:function(){return o["public"].binders["if"].unbind.call(this)},routine:function(n,e){return o["public"].binders["if"].routine.call(this,n,!e)},update:function(n){return o["public"].binders["if"].update.call(this,n)}},o["public"].binders["on-*"]={"function":!0,priority:1e3,unbind:function(n){return this.handler?o.Util.unbindEvent(n,this.args[0],this.handler):void 0},routine:function(n,e){return this.handler&&o.Util.unbindEvent(n,this.args[0],this.handler),o.Util.bindEvent(n,this.args[0],this.handler=this.eventHandler(e))}},o["public"].binders["each-*"]={block:!0,priority:4e3,bind:function(n){var e,t,r,i,o;if(null==this.marker)e=[this.view.prefix,this.type].join("-").replace("--","-"),this.marker=document.createComment(" rivets: "+this.type+" "),this.iterated=[],n.removeAttribute(e),n.parentNode.insertBefore(this.marker,n),n.parentNode.removeChild(n);else for(o=this.iterated,r=0,i=o.length;i>r;r++)t=o[r],t.bind()},unbind:function(n){var e,t,r,i,o;if(null!=this.iterated){for(i=this.iterated,o=[],t=0,r=i.length;r>t;t++)e=i[t],o.push(e.unbind());return o}},routine:function(n,e){var t,r,i,s,a,u,l,f,c,h,p,d,g,m,b,v,y,w,x,k,E;if(l=this.args[0],e=e||[],this.iterated.length>e.length)for(w=Array(this.iterated.length-e.length),d=0,b=w.length;b>d;d++)i=w[d],p=this.iterated.pop(),p.unbind(),this.marker.parentNode.removeChild(p.els[0]);for(s=g=0,v=e.length;v>g;s=++g)if(u=e[s],r={index:s},r[l]=u,null==this.iterated[s]){x=this.view.models;for(a in x)u=x[a],null==r[a]&&(r[a]=u);c=this.iterated.length?this.iterated[this.iterated.length-1].els[0]:this.marker,f=this.view.options(),f.preloadData=!0,h=n.cloneNode(!0),p=new o.View(h,r,f),p.bind(),this.iterated.push(p),this.marker.parentNode.insertBefore(h,c.nextSibling)}else this.iterated[s].models[l]!==u&&this.iterated[s].update(r);if("OPTION"===n.nodeName){for(k=this.view.bindings,E=[],m=0,y=k.length;y>m;m++)t=k[m],t.el===this.marker.parentNode&&"value"===t.type?E.push(t.sync()):E.push(void 0);return E}},update:function(n){var e,t,r,i,o,s,a,u;e={};for(t in n)r=n[t],t!==this.args[0]&&(e[t]=r);for(a=this.iterated,u=[],o=0,s=a.length;s>o;o++)i=a[o],u.push(i.update(e));return u}},o["public"].binders["class-*"]=function(n,e){var t;return t=" "+n.className+" ",!e==(-1!==t.indexOf(" "+this.args[0]+" "))?n.className=e?""+n.className+" "+this.args[0]:t.replace(" "+this.args[0]+" "," ").trim():void 0},o["public"].binders["*"]=function(n,e){return null!=e?n.setAttribute(this.type,e):n.removeAttribute(this.type)},o["public"].adapters["."]={id:"_rv",counter:0,weakmap:{},weakReference:function(n){var e,t,r;return n.hasOwnProperty(this.id)||(e=this.counter++,Object.defineProperty(n,this.id,{value:e})),(t=this.weakmap)[r=n[this.id]]||(t[r]={callbacks:{}})},cleanupWeakReference:function(n,e){return Object.keys(n.callbacks).length||n.pointers&&Object.keys(n.pointers).length?void 0:delete this.weakmap[e]},stubFunction:function(n,e){var t,r,i;return r=n[e],t=this.weakReference(n),i=this.weakmap,n[e]=function(){var e,o,s,a,u,l,f,c,h,p;a=r.apply(n,arguments),f=t.pointers;for(s in f)for(o=f[s],p=null!=(c=null!=(h=i[s])?h.callbacks[o]:void 0)?c:[],u=0,l=p.length;l>u;u++)(e=p[u])();return a}},observeMutations:function(n,e,t){var r,i,o,s,a,u;if(Array.isArray(n)){if(o=this.weakReference(n),null==o.pointers)for(o.pointers={},i=["push","pop","shift","unshift","sort","reverse","splice"],a=0,u=i.length;u>a;a++)r=i[a],this.stubFunction(n,r);if(null==(s=o.pointers)[e]&&(s[e]=[]),p.call(o.pointers[e],t)<0)return o.pointers[e].push(t)}},unobserveMutations:function(n,e,t){var r,i,o;return Array.isArray(n)&&null!=n[this.id]&&(i=this.weakmap[n[this.id]])&&(o=i.pointers[e])?((r=o.indexOf(t))>=0&&o.splice(r,1),o.length||delete i.pointers[e],this.cleanupWeakReference(i,n[this.id])):void 0},observe:function(n,e,t){var r,i,o;return r=this.weakReference(n).callbacks,null==r[e]&&(r[e]=[],i=Object.getOwnPropertyDescriptor(n,e),(null!=i?i.get:void 0)||(null!=i?i.set:void 0)||(o=n[e],Object.defineProperty(n,e,{enumerable:!0,get:function(){return o},set:function(i){return function(s){var a,u,l,f;if(s!==o&&(i.unobserveMutations(o,n[i.id],e),o=s,a=i.weakmap[n[i.id]])){if(r=a.callbacks,r[e])for(f=r[e].slice(),u=0,l=f.length;l>u;u++)t=f[u],p.call(r[e],t)>=0&&t();return i.observeMutations(s,n[i.id],e)}}}(this)}))),p.call(r[e],t)<0&&r[e].push(t),this.observeMutations(n[e],n[this.id],e)},unobserve:function(n,e,t){var r,i,o;return(o=this.weakmap[n[this.id]])&&(r=o.callbacks[e])?((i=r.indexOf(t))>=0&&(r.splice(i,1),r.length||delete o.callbacks[e]),this.unobserveMutations(n[e],n[this.id],e),this.cleanupWeakReference(o,n[this.id])):void 0},get:function(n,e){return n[e]},set:function(n,e,t){return n[e]=t}},o.factory=function(n){return o.sightglass=n,o["public"]._=o,o["public"]},"object"==typeof("undefined"!=typeof n&&null!==n?n.exports:void 0)?n.exports=o.factory(t(9)):(r=[t(9)],i=function(n){return this.rivets=o.factory(n)}.apply(e,r),!(void 0!==i&&(n.exports=i)))}).call(this)}).call(e,t(10)(n))},function(n,e,t){var r=t(21);"string"==typeof r&&(r=[[n.id,r,""]]);t(3)(r,{});r.locals&&(n.exports=r.locals)},function(n,e){"use strict";var t=function(n){return n.replace(/(?:^\w|[A-Z]|\b\w)/g,function(n,e){return 0==e?n.toLowerCase():n.toUpperCase()}).replace(/\s+/g,"")};n.exports=t},,function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{"default":n}}function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),s=t(1),a=(r(s),t(17)),u=r(a),l=function(){function n(e,t){i(this,n),this.nOutput=e,this.iSpeed=t?16:1,this.bPaused=!1,this.bIsWritting=!1}return o(n,[{key:"init",value:function(n){var e=this;return new Promise(function(t,r){e._startWritting(t,n,e.nOutput,e.iSpeed)})}},{key:"stop",value:function(){this.bPaused=!0}},{key:"isWritting",value:function(){return this.bIsWritting}},{key:"_startWritting",value:function(n,e,t,r){this._runWrite(n,e,0,1)}},{key:"_runWrite",value:function(n,e,t,r){var i=this,o=e.slice(t,t+r);t+=r,u["default"].simple(this.nOutput,o),Prism.highlightAll();var s=/\D[\,]\s$/,a=/[^\/]\n\n$/,l=/[^\/]\n$/,f=/[\{!]\s$/;if(this.bPaused||!(t<e.length))return this.bIsWritting=!1,n();this.bIsWritting=!0;var c=this.iSpeed,h=e.slice(t-2,t+1);s.test(h),a.test(h)&&(c=50*this.iSpeed),l.test(h)&&!f.test(h)&&(c=50*this.iSpeed,window.scrollTo(0,document.body.scrollHeight)),setTimeout(function(){i._runWrite(n,e,t,r)},c)}}]),n}();e["default"]=l},function(n,e){"use strict";var t="",r={};n.exports=function(e,i,o){var s=r[e.id];s||(s=r[e.id]=e.innerHTML),s=n.exports.handleChar(s,i),e.innerHTML=r[e.id]=s,t+=i,";"===i&&(o.textContent+=t,t="")},n.exports.simple=function(n,e){n.innerHTML+=e};var i=!1,o=/(\/\*(?:[^](?!\/\*))*\*)$/,s=/([a-zA-Z- ^\n]*)$/,a=/([^:]*)$/,u=/(.*)$/,l=/\dp/,f=/p$/;n.exports.handleChar=function(n,e){return i&&"/"!==e?n+=e:"/"===e&&i===!1?(i=!0,n+=e):"/"===e&&"*"===n.slice(-1)&&i===!0?(i=!1,n=n.replace(o,'<span class="comment">$1/</span>')):":"===e?n=n.replace(s,'<span class="key">$1</span>:'):";"===e?n=n.replace(a,'<span class="value">$1</span>;'):"{"===e?n=n.replace(u,'<span class="selector">$1</span>{'):"x"===e&&l.test(n.slice(-2))?n=n.replace(f,'<span class="value px">px</span>'):n+=e,n}},function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{"default":n}}function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function o(n,e){if(!n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?n:e}function s(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(n,e):n.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,
"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),u=t(6),l=r(u),f=t(1),c=(r(f),t(7)),h=r(c),p=t(16),d=r(p),g=(t(5),function(n){function e(n){i(this,e);var t=o(this,Object.getPrototypeOf(e).call(this,n));return t.sName=n,t.bIsTecnic=!1,t.nOutputCtn=null,t}return s(e,n),a(e,[{key:"initOutpupCtn",value:function(n){this.nOutputCtn=document.getElementById(n),this.WriteClass=new d["default"](this.nOutputCtn,this.bIsTecnic)}},{key:"initWrite",value:function(n){return this.WriteClass.init(n)}},{key:"showOutput",value:function(n){this._getRawText(n)}},{key:"removeOutput",value:function(){var n=this;this.WriteClass.stop(),setTimeout(function(){n.nOutputCtn.innerHTML=""},100)}},{key:"_getRawText",value:function(n){var e=this,t=this._getLanguage(n);(0,l["default"])("./tree/"+n+".txt").then(function(n){e._displayOutput(n,t)})}},{key:"_displayOutput",value:function(n,e){this.WriteClass.isWritting&&this.WriteClass.stop(),"language-html"==e&&(n=this._htmlEntities(n)),this.nOutputCtn.innerHTML=n,this.nOutputCtn.className="",this.nOutputCtn.classList.add(e),Prism.highlightAll()}},{key:"_getLanguage",value:function(n){return-1!==n.indexOf(".html")?"language-html":-1!==n.indexOf(".css")?"language-css":"language-js"}},{key:"_htmlEntities",value:function(n){return String(n).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")}}]),e}(h["default"]));e["default"]=g},function(n,e,t){function r(n,e,t,r){var o={showHidden:e,seen:[],stylize:function(n){return n}};return i(o,n,"undefined"==typeof t?2:t)}function i(n,t,r){if(t&&"function"==typeof t.inspect&&t.inspect!==e.inspect&&(!t.constructor||t.constructor.prototype!==t)){var d=t.inspect(r);return"string"!=typeof d&&(d=i(n,d,r)),d}var y=o(n,t);if(y)return y;if(v(t)){if("outerHTML"in t)return t.outerHTML;try{if(document.xmlVersion){var w=new XMLSerializer;return w.serializeToString(t)}var x="http://www.w3.org/1999/xhtml",k=document.createElementNS(x,"_");return k.appendChild(t.cloneNode(!1)),html=k.innerHTML.replace("><",">"+t.innerHTML+"<"),k.innerHTML="",html}catch(E){}}var _=b(t),S=n.showHidden?m(t):_;if(0===S.length||p(t)&&(1===S.length&&"stack"===S[0]||2===S.length&&"description"===S[0]&&"stack"===S[1])){if("function"==typeof t){var T=g(t),O=T?": "+T:"";return n.stylize("[Function"+O+"]","special")}if(c(t))return n.stylize(RegExp.prototype.toString.call(t),"regexp");if(h(t))return n.stylize(Date.prototype.toUTCString.call(t),"date");if(p(t))return s(t)}var A="",R=!1,I=["{","}"];if(f(t)&&(R=!0,I=["[","]"]),"function"==typeof t){var T=g(t),O=T?": "+T:"";A=" [Function"+O+"]"}if(c(t)&&(A=" "+RegExp.prototype.toString.call(t)),h(t)&&(A=" "+Date.prototype.toUTCString.call(t)),p(t))return s(t);if(0===S.length&&(!R||0==t.length))return I[0]+A+I[1];if(0>r)return c(t)?n.stylize(RegExp.prototype.toString.call(t),"regexp"):n.stylize("[Object]","special");n.seen.push(t);var j;return j=R?a(n,t,r,_,S):S.map(function(e){return u(n,t,r,_,e,R)}),n.seen.pop(),l(j,A,I)}function o(n,e){switch(typeof e){case"undefined":return n.stylize("undefined","undefined");case"string":var t="'"+JSON.stringify(e).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return n.stylize(t,"string");case"number":return 0===e&&1/e===-(1/0)?n.stylize("-0","number"):n.stylize(""+e,"number");case"boolean":return n.stylize(""+e,"boolean")}return null===e?n.stylize("null","null"):void 0}function s(n){return"["+Error.prototype.toString.call(n)+"]"}function a(n,e,t,r,i){for(var o=[],s=0,a=e.length;a>s;++s)Object.prototype.hasOwnProperty.call(e,String(s))?o.push(u(n,e,t,r,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(u(n,e,t,r,i,!0))}),o}function u(n,e,t,r,o,s){var a,u;if(e.__lookupGetter__&&(e.__lookupGetter__(o)?u=e.__lookupSetter__(o)?n.stylize("[Getter/Setter]","special"):n.stylize("[Getter]","special"):e.__lookupSetter__(o)&&(u=n.stylize("[Setter]","special"))),r.indexOf(o)<0&&(a="["+o+"]"),u||(n.seen.indexOf(e[o])<0?(u=null===t?i(n,e[o],null):i(n,e[o],t-1),u.indexOf("\n")>-1&&(u=s?u.split("\n").map(function(n){return"  "+n}).join("\n").substr(2):"\n"+u.split("\n").map(function(n){return"   "+n}).join("\n"))):u=n.stylize("[Circular]","special")),"undefined"==typeof a){if(s&&o.match(/^\d+$/))return u;a=JSON.stringify(""+o),a.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(a=a.substr(1,a.length-2),a=n.stylize(a,"name")):(a=a.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),a=n.stylize(a,"string"))}return a+": "+u}function l(n,e,t){var r=0,i=n.reduce(function(n,e){return r++,e.indexOf("\n")>=0&&r++,n+e.length+1},0);return i>60?t[0]+(""===e?"":e+"\n ")+" "+n.join(",\n  ")+" "+t[1]:t[0]+e+" "+n.join(", ")+" "+t[1]}function f(n){return Array.isArray(n)||"object"==typeof n&&"[object Array]"===d(n)}function c(n){return"object"==typeof n&&"[object RegExp]"===d(n)}function h(n){return"object"==typeof n&&"[object Date]"===d(n)}function p(n){return"object"==typeof n&&"[object Error]"===d(n)}function d(n){return Object.prototype.toString.call(n)}var g=t(39),m=t(74),b=t(71);n.exports=r;var v=function(n){return"object"==typeof HTMLElement?n instanceof HTMLElement:n&&"object"==typeof n&&1===n.nodeType&&"string"==typeof n.nodeName}},function(n,e,t){n.exports=t(84)},function(n,e,t){e=n.exports=t(2)(),e.push([n.id,'/*! normalize.css v4.0.0 | MIT License | github.com/necolas/normalize.css */progress,sub,sup{vertical-align:baseline}button,hr,input,select{overflow:visible}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{cursor:pointer}[disabled]{cursor:default}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}button:-moz-focusring,input:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}.cf:after,.cf:before{content:" ";display:table}.cf:after{clear:both}li,ul{list-style:none;margin:0;padding:0}*,:after,:before{box-sizing:border-box}.list--inline li{display:inline-block;margin:0 7px}.btn-reset{display:inline-block;background-color:transparent;border:none;text-align:center;text-decoration:none;cursor:pointer}.btn-reset:focus{outline:none}.sublime{display:none;position:fixed;left:0;top:0;z-index:0}body{font:14/16 arial,helvetica,sans-serif;color:#fff}.app{//:.8;position:fixed;left:0;top:0;z-index:1;width:100%;height:100%}.app__bar{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-justify-content:space-around;-ms-flex-pack:distribute;justify-content:space-around;height:48px;padding:0 10px;background-color:#2d2d2d;font-size:14px}.app__bar__top{-webkit-align-self:center;-ms-flex-item-align:center;align-self:center}.app__main{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;-webkit-align-content:stretch;-ms-flex-line-pack:stretch;align-content:stretch;height:100%}.app__main__content{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;width:1px;height:100%}::-webkit-scrollbar{width:10px;background-color:#222;border-radius:10px}::-webkit-scrollbar-thumb{background-color:#565656;border-radius:10px}',""])},function(n,e,t){e=n.exports=t(2)(),e.push([n.id,"/*! normalize.css v4.0.0 | MIT License | github.com/necolas/normalize.css */progress,sub,sup{vertical-align:baseline}button,hr,input,select{overflow:visible}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{cursor:pointer}[disabled]{cursor:default}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}button:-moz-focusring,input:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-scrollbar{width:10px;background-color:#222;border-radius:10px}::-webkit-scrollbar-thumb{background-color:#565656;border-radius:10px}.editor__inner{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;height:calc(100% - - 48px);height:calc(100% - 33px - 48px);padding:5px}.editor__inner__content{overflow:auto;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1}.editor__inner__content pre{margin:0;padding:0;background-color:#141414;border:none;border-radius:0;box-shadow:none}.editor__inner__content code[class*=language-],.editor__inner__content pre[class*=language-]{line-height:18px}",""])},function(n,e,t){e=n.exports=t(2)(),e.push([n.id,"/*! normalize.css v4.0.0 | MIT License | github.com/necolas/normalize.css */progress,sub,sup{vertical-align:baseline}button,hr,input,select{overflow:visible}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{cursor:pointer}[disabled]{cursor:default}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}button:-moz-focusring,input:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}.gutter{width:50px;height:100%;padding:0 20px 0 15px;font-size:13px;color:#555;text-align:right}",""])},function(n,e,t){e=n.exports=t(2)(),e.push([n.id,"/*! normalize.css v4.0.0 | MIT License | github.com/necolas/normalize.css */progress,sub,sup{vertical-align:baseline}button,hr,input,select{overflow:visible}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{cursor:pointer}[disabled]{cursor:default}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}button:-moz-focusring,input:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}.editor{background-color:#141414}.editor__tab{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;width:100%;height:33px;padding:0 0 50px;padding:5px 0 0 50px;background-color:#565656}.editor__tab__item{position:relative;z-index:1;max-width:175px;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:-12px;padding:0 10px;height:0;line-height:calc(-);line-height:-5px;line-height:calc(33px -);line-height:28px;border-bottom:calc(-) solid;border-bottom:calc(-) solid #666;border-bottom:-5px solid;border-bottom:-5px solid #666;border-bottom:calc(33px -) solid;border-bottom:calc(33px -) solid #666;border-bottom:28px solid;border-bottom:28px solid #666;border-left:15px solid transparent;border-right:15px solid transparent;font-size:13px;cursor:default}.editor__tab__item.jsIsActive{z-index:2;border-bottom-color:#141414}.editor__tab__item__open{width:84%;color:#fff;text-align:left}.editor__tab__item__close{position:absolute;top:0;right:0;width:30px;height:calc(-);height:-5px;height:calc(33px -);height:28px;color:#fff;cursor:default;outline:none}",""])},function(n,e,t){e=n.exports=t(2)(),e.push([n.id,'/*! normalize.css v4.0.0 | MIT License | github.com/necolas/normalize.css */progress,sub,sup{vertical-align:baseline}button,hr,input,select{overflow:visible}[type=checkbox],[type=radio],legend{box-sizing:border-box;padding:0}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}button,input,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{cursor:pointer}[disabled]{cursor:default}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}button:-moz-focusring,input:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{color:inherit;display:table;max-width:100%;white-space:normal}textarea{overflow:auto}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}.btn-tree{height:24px;line-height:24px}.btn-tree--folder{font-weight:700}.btn-tree--arrow:before{content:\'\';position:absolute;left:0;top:10px;display:block;width:10px;height:8px;background-image:url(\'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="32" height="24" viewBox="0 0 32 24"><polygon points="0,0 32,0 16,24" style="fill: #666"></polygon></svg>\');background-size:10px 8px;background-position:50%;background-origin:content-box;background-repeat:no-repeat;-webkit-transform:rotate(-90deg);transform:rotate(-90deg);-webkit-transition:-webkit-transform .1s linear;transition:-webkit-transform .1s linear;transition:transform .1s linear;transition:transform .1s linear,-webkit-transform .1s linear}.btn-tree--arrow.jsIsOpen:before{-webkit-transform:rotate(0);transform:rotate(0)}.tree{width:246px;height:100%;padding:20px 10px;font-family:Inconsolata,courier;font-weight:400;color:#000}.tree strong{font-weight:700}.tree ul ul ul{padding-left:8px}.tree ul ul ul ul{padding-left:16px}.tree ul ul ul ul ul{padding-left:24px}.tree__item{position:relative;padding-left:10px}.tree__item .jsisfolder+ul{max-height:0;overflow:hidden;-webkit-transition:max-height .1s linear;transition:max-height .1s linear}.tree__item .jsisfolder.jsIsOpen+ul{max-height:100px}.tree__item--root>ul{margin-top:3px}',""])},function(n,e){n.exports="<div class=editor__inner> <div id=jsGutter class=gutter></div> <div class=editor__inner__content> <pre style=cursor:text><code id=jsCodeContent class=language-js></code>\n        </pre> </div> </div>"},function(n,e){n.exports="<li my-each-gutter=line class=gutter__item> {{iLine}} </li>"},function(n,e){n.exports='<ul class=editor__tab> <li my-each-tab=tab class=editor__tab__item my-class-jsisactive=tab.active> <button type=button class="jsEventTabItem btn-reset editor__tab__item__open" my-data-name=tab.name my-data-full-path=tab.fullPath> {{ tab.name }} </button> <button type=button class="jsEventTabItemClose btn-reset editor__tab__item__close" my-data-name=tab.name my-data-full-path=tab.fullPath> x </button> </li> </ul>'},function(n,e){n.exports='<ul> <li class="tree__item tree__item--root"> <span class="btn-tree btn-tree--folder"> {{ title }} </span> <ul> <li my-each-root=tree class=tree__item> <button type=button class="jsEventMenuItem btn-reset btn-tree" my-class-btn-tree--folder=root.isFolder my-class-btn-tree--arrow=root.isFolder my-class-jsisfolder=root.isFolder my-data-name=root.name my-data-full-path=root.fullPath> {{ root.name }} </button> <ul> <li my-each-level1=root.level1 class=tree__item> <button type=button class="jsEventMenuItem btn-reset btn-tree" my-class-btn-tree--folder=level1.isFolder my-class-btn-tree--arrow=level1.isFolder my-class-jsisfolder=level1.isFolder my-data-name=level1.name my-data-full-path=level1.fullPath> {{ level1.name }} </button> <ul> <li my-each-level2=level1.level2 class=tree__item> <button type=button class="jsEventMenuItem btn-reset btn-tree" my-class-btn-tree--folder=level2.isFolder my-data-name=level2.name my-data-full-path=level2.fullPath> {{ level2.name }} </button> </li> </ul> </li> </ul> </li> </ul> </li> </ul>'},function(n,e,t){var r;(function(n,i){(function(){function o(n,e){return n.set(e[0],e[1]),n}function s(n,e){return n.add(e),n}function a(n,e,t){var r=t.length;switch(r){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}function u(n,e,t,r){for(var i=-1,o=n.length;++i<o;){var s=n[i];e(r,s,t(s),n)}return r}function l(n,e){for(var t=-1,r=n.length,i=-1,o=e.length,s=Array(r+o);++t<r;)s[t]=n[t];for(;++i<o;)s[t++]=e[i];return s}function f(n,e){for(var t=-1,r=n.length;++t<r&&e(n[t],t,n)!==!1;);return n}function c(n,e){for(var t=n.length;t--&&e(n[t],t,n)!==!1;);return n}function h(n,e){for(var t=-1,r=n.length;++t<r;)if(!e(n[t],t,n))return!1;return!0}function p(n,e){for(var t=-1,r=n.length,i=0,o=[];++t<r;){var s=n[t];e(s,t,n)&&(o[i++]=s)}return o}function d(n,e){return!!n.length&&E(n,e,0)>-1}function g(n,e,t){for(var r=-1,i=n.length;++r<i;)if(t(e,n[r]))return!0;return!1}function m(n,e){for(var t=-1,r=n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}function b(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}function v(n,e,t,r){var i=-1,o=n.length;for(r&&o&&(t=n[++i]);++i<o;)t=e(t,n[i],i,n);return t}function y(n,e,t,r){var i=n.length;for(r&&i&&(t=n[--i]);i--;)t=e(t,n[i],i,n);return t}function w(n,e){for(var t=-1,r=n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}function x(n,e,t,r){var i;return t(n,function(n,t,o){return e(n,t,o)?(i=r?t:n,!1):void 0}),i}function k(n,e,t){for(var r=n.length,i=t?r:-1;t?i--:++i<r;)if(e(n[i],i,n))return i;return-1}function E(n,e,t){if(e!==e)return U(n,t);for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}function _(n,e,t,r){for(var i=t-1,o=n.length;++i<o;)if(r(n[i],e))return i;return-1}function S(n,e){var t=n?n.length:0;return t?A(n,e)/t:Sn}function T(n,e,t,r,i){return i(n,function(n,i,o){t=r?(r=!1,n):e(t,n,i,o)}),t}function O(n,e){var t=n.length;for(n.sort(e);t--;)n[t]=n[t].value;return n}function A(n,e){for(var t,r=-1,i=n.length;++r<i;){var o=e(n[r]);o!==X&&(t=t===X?o:t+o)}return t}function R(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}function I(n,e){return m(e,function(e){return[e,n[e]]})}function j(n){return function(e){return n(e)}}function B(n,e){return m(e,function(e){return n[e]})}function L(n,e){for(var t=-1,r=n.length;++t<r&&E(e,n[t],0)>-1;);return t}function P(n,e){for(var t=n.length;t--&&E(e,n[t],0)>-1;);return t}function N(n){return n&&n.Object===Object?n:null}function C(n,e){for(var t=n.length,r=0;t--;)n[t]===e&&r++;return r}function M(n){return Ot[n]}function D(n){return At[n]}function F(n){return"\\"+jt[n]}function U(n,e,t){for(var r=n.length,i=e+(t?0:-1);t?i--:++i<r;){var o=n[i];if(o!==o)return i}return-1}function q(n){var e=!1;if(null!=n&&"function"!=typeof n.toString)try{e=!!(n+"")}catch(t){}return e}function z(n){for(var e,t=[];!(e=n.next()).done;)t.push(e.value);return t}function H(n){var e=-1,t=Array(n.size);return n.forEach(function(n,r){t[++e]=[r,n]}),t}function W(n,e){for(var t=-1,r=n.length,i=0,o=[];++t<r;){var s=n[t];(s===e||s===en)&&(n[t]=en,o[i++]=t)}return o}function Y(n){var e=-1,t=Array(n.size);return n.forEach(function(n){t[++e]=n}),t}function $(n){if(!n||!xt.test(n))return n.length;for(var e=yt.lastIndex=0;yt.test(n);)e++;return e}function G(n){return n.match(yt)}function J(n){return Rt[n]}function V(n){function e(n){if(la(n)&&!ec(n)&&!(n instanceof i)){if(n instanceof r)return n;if(dl.call(n,"__wrapped__"))return eo(n)}return new r(n)}function t(){}function r(n,e){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!e,this.__index__=0,this.__values__=X}function i(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Tn,this.__views__=[]}function N(){var n=new i(this.__wrapped__);return n.__actions__=Xr(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Xr(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Xr(this.__views__),n}function Pe(){if(this.__filtered__){var n=new i(this);n.__dir__=-1,n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Ne(){var n=this.__wrapped__.value(),e=this.__dir__,t=ec(n),r=0>e,i=t?n.length:0,o=Li(0,i,this.__views__),s=o.start,a=o.end,u=a-s,l=r?a:s-1,f=this.__iteratees__,c=f.length,h=0,p=Fl(u,this.__takeCount__);if(!t||Q>i||i==u&&p==u)return jr(n,this.__actions__);var d=[];n:for(;u--&&p>h;){l+=e;for(var g=-1,m=n[l];++g<c;){var b=f[g],v=b.iteratee,y=b.type,w=v(m);if(y==wn)m=w;else if(!w){if(y==yn)continue n;break n}}d[h++]=m}return d}function Ce(){}function Me(n,e){return Fe(n,e)&&delete n[e]}function De(n,e){if(Xl){var t=n[e];return t===nn?X:t}return dl.call(n,e)?n[e]:X}function Fe(n,e){return Xl?n[e]!==X:dl.call(n,e)}function Ue(n,e,t){n[e]=Xl&&t===X?nn:t}function qe(n){var e=-1,t=n?n.length:0;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}function ze(){this.__data__={hash:new Ce,map:$l?new $l:[],string:new Ce}}function He(n){var e=this.__data__;return Wi(n)?Me("string"==typeof n?e.string:e.hash,n):$l?e.map["delete"](n):tt(e.map,n)}function We(n){var e=this.__data__;return Wi(n)?De("string"==typeof n?e.string:e.hash,n):$l?e.map.get(n):rt(e.map,n)}function Ye(n){var e=this.__data__;return Wi(n)?Fe("string"==typeof n?e.string:e.hash,n):$l?e.map.has(n):it(e.map,n)}function $e(n,e){var t=this.__data__;return Wi(n)?Ue("string"==typeof n?t.string:t.hash,n,e):$l?t.map.set(n,e):st(t.map,n,e),this}function Ge(n){var e=-1,t=n?n.length:0;for(this.__data__=new qe;++e<t;)this.push(n[e])}function Je(n,e){var t=n.__data__;if(Wi(e)){var r=t.__data__,i="string"==typeof e?r.string:r.hash;return i[e]===nn}return t.has(e)}function Ve(n){var e=this.__data__;if(Wi(n)){var t=e.__data__,r="string"==typeof n?t.string:t.hash;r[n]=nn}else e.set(n,nn)}function Xe(n){var e=-1,t=n?n.length:0;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}function Ke(){this.__data__={array:[],map:null}}function Qe(n){var e=this.__data__,t=e.array;return t?tt(t,n):e.map["delete"](n)}function Ze(n){var e=this.__data__,t=e.array;return t?rt(t,n):e.map.get(n)}function nt(n){var e=this.__data__,t=e.array;return t?it(t,n):e.map.has(n)}function et(n,e){var t=this.__data__,r=t.array;r&&(r.length<Q-1?st(r,n,e):(t.array=null,t.map=new qe(r)));var i=t.map;return i&&i.set(n,e),this}function tt(n,e){var t=ot(n,e);if(0>t)return!1;var r=n.length-1;return t==r?n.pop():jl.call(n,t,1),!0}function rt(n,e){var t=ot(n,e);return 0>t?X:n[t][1]}function it(n,e){return ot(n,e)>-1}function ot(n,e){for(var t=n.length;t--;)if($s(n[t][0],e))return t;return-1}function st(n,e,t){var r=ot(n,e);0>r?n.push([e,t]):n[r][1]=t}function at(n,e,t,r){return n===X||$s(n,cl[t])&&!dl.call(r,t)?e:n}function ut(n,e,t){(t!==X&&!$s(n[e],t)||"number"==typeof e&&t===X&&!(e in n))&&(n[e]=t)}function lt(n,e,t){var r=n[e];dl.call(n,e)&&$s(r,t)&&(t!==X||e in n)||(n[e]=t)}function ft(n,e,t,r){return lf(n,function(n,i,o){e(r,n,t(n),o)}),r}function ct(n,e){return n&&Kr(e,Ga(e),n)}function ht(n,e){for(var t=-1,r=null==n,i=e.length,o=Array(i);++t<i;)o[t]=r?X:Wa(n,e[t]);return o}function pt(n,e,t){return n===n&&(t!==X&&(n=t>=n?n:t),e!==X&&(n=n>=e?n:e)),n}function dt(n,e,t,r,i,o,s){var a;if(r&&(a=o?r(n,i,o,s):r(n)),a!==X)return a;if(!ua(n))return n;var u=ec(n);if(u){if(a=Ni(n),!e)return Xr(n,a)}else{var l=Bi(n),c=l==Pn||l==Nn;if(tc(n))return Dr(n,e);if(l==Dn||l==Rn||c&&!o){if(q(n))return o?n:{};if(a=Ci(c?{}:n),!e)return Qr(n,ct(a,n))}else{if(!Tt[l])return o?n:{};a=Mi(n,l,dt,e)}}s||(s=new Xe);var h=s.get(n);if(h)return h;if(s.set(n,a),!u)var p=t?Ei(n):Ga(n);return f(p||n,function(i,o){p&&(o=i,i=n[o]),lt(a,o,dt(i,e,t,r,o,n,s))}),a}function gt(n){var e=Ga(n),t=e.length;return function(r){if(null==r)return!t;for(var i=t;i--;){var o=e[i],s=n[o],a=r[o];if(a===X&&!(o in Object(r))||!s(a))return!1}return!0}}function mt(n){return ua(n)?Al(n):{}}function yt(n,e,t){if("function"!=typeof n)throw new ll(Z);return Il(function(){n.apply(X,t)},e)}function Ot(n,e,t,r){var i=-1,o=d,s=!0,a=n.length,u=[],l=e.length;if(!a)return u;t&&(e=m(e,j(t))),r?(o=g,s=!1):e.length>=Q&&(o=Je,s=!1,e=new Ge(e));n:for(;++i<a;){var f=n[i],c=t?t(f):f;if(f=r||0!==f?f:0,s&&c===c){for(var h=l;h--;)if(e[h]===c)continue n;u.push(f)}else o(e,c,r)||u.push(f)}return u}function At(n,e){var t=!0;return lf(n,function(n,r,i){return t=!!e(n,r,i)}),t}function Rt(n,e,t){for(var r=-1,i=n.length;++r<i;){var o=n[r],s=e(o);if(null!=s&&(a===X?s===s&&!Ea(s):t(s,a)))var a=s,u=o}return u}function It(n,e,t,r){var i=n.length;for(t=Ra(t),0>t&&(t=-t>i?0:i+t),r=r===X||r>i?i:Ra(r),0>r&&(r+=i),r=t>r?0:Ia(r);r>t;)n[t++]=e;return n}function jt(n,e){var t=[];return lf(n,function(n,r,i){e(n,r,i)&&t.push(n)}),t}function Pt(n,e,t,r,i){var o=-1,s=n.length;for(t||(t=Fi),i||(i=[]);++o<s;){var a=n[o];e>0&&t(a)?e>1?Pt(a,e-1,t,r,i):b(i,a):r||(i[i.length]=a)}return i}function Nt(n,e){return n&&cf(n,e,Ga)}function Mt(n,e){return n&&hf(n,e,Ga)}function Dt(n,e){return p(e,function(e){return oa(n[e])})}function Ft(n,e){e=Hi(e,n)?[e]:Cr(e);for(var t=0,r=e.length;null!=n&&r>t;)n=n[Zi(e[t++])];return t&&t==r?n:X}function Ut(n,e,t){var r=e(n);return ec(n)?r:b(r,t(n))}function Ht(n,e){return n>e}function Wt(n,e){return dl.call(n,e)||"object"==typeof n&&e in n&&null===Ii(n)}function Yt(n,e){return e in Object(n)}function $t(n,e,t){return n>=Fl(e,t)&&n<Dl(e,t)}function Gt(n,e,t){for(var r=t?g:d,i=n[0].length,o=n.length,s=o,a=Array(o),u=1/0,l=[];s--;){var f=n[s];s&&e&&(f=m(f,j(e))),u=Fl(f.length,u),a[s]=!t&&(e||i>=120&&f.length>=120)?new Ge(s&&f):X}f=n[0];var c=-1,h=a[0];n:for(;++c<i&&l.length<u;){var p=f[c],b=e?e(p):p;if(p=t||0!==p?p:0,!(h?Je(h,b):r(l,b,t))){for(s=o;--s;){var v=a[s];if(!(v?Je(v,b):r(n[s],b,t)))continue n}h&&h.push(b),l.push(p)}}return l}function Jt(n,e,t,r){return Nt(n,function(n,i,o){e(r,t(n),i,o)}),r}function Vt(n,e,t){Hi(e,n)||(e=Cr(e),n=Ki(n,e),e=xo(e));var r=null==n?n:n[Zi(e)];return null==r?X:a(r,n,t)}function Xt(n,e,t,r,i){return n===e?!0:null==n||null==e||!ua(n)&&!la(e)?n!==n&&e!==e:Kt(n,e,Xt,t,r,i)}function Kt(n,e,t,r,i,o){var s=ec(n),a=ec(e),u=In,l=In;s||(u=Bi(n),u=u==Rn?Dn:u),a||(l=Bi(e),l=l==Rn?Dn:l);var f=u==Dn&&!q(n),c=l==Dn&&!q(e),h=u==l;if(h&&!f)return o||(o=new Xe),s||_a(n)?wi(n,e,t,r,i,o):xi(n,e,u,t,r,i,o);if(!(i&dn)){var p=f&&dl.call(n,"__wrapped__"),d=c&&dl.call(e,"__wrapped__");
if(p||d){var g=p?n.value():n,m=d?e.value():e;return o||(o=new Xe),t(g,m,r,i,o)}}return h?(o||(o=new Xe),ki(n,e,t,r,i,o)):!1}function Qt(n,e,t,r){var i=t.length,o=i,s=!r;if(null==n)return!o;for(n=Object(n);i--;){var a=t[i];if(s&&a[2]?a[1]!==n[a[0]]:!(a[0]in n))return!1}for(;++i<o;){a=t[i];var u=a[0],l=n[u],f=a[1];if(s&&a[2]){if(l===X&&!(u in n))return!1}else{var c=new Xe;if(r)var h=r(l,f,u,n,e,c);if(!(h===X?Xt(f,l,r,pn|dn,c):h))return!1}}return!0}function Zt(n){return"function"==typeof n?n:null==n?Du:"object"==typeof n?ec(n)?or(n[0],n[1]):ir(n):$u(n)}function nr(n){return Ml(Object(n))}function er(n){n=null==n?n:Object(n);var e=[];for(var t in n)e.push(t);return e}function tr(n,e){return e>n}function rr(n,e){var t=-1,r=Vs(n)?Array(n.length):[];return lf(n,function(n,i,o){r[++t]=e(n,i,o)}),r}function ir(n){var e=Oi(n);return 1==e.length&&e[0][2]?Ji(e[0][0],e[0][1]):function(t){return t===n||Qt(t,n,e)}}function or(n,e){return Hi(n)&&Gi(e)?Ji(Zi(n),e):function(t){var r=Wa(t,n);return r===X&&r===e?$a(t,n):Xt(e,r,X,pn|dn)}}function sr(n,e,t,r,i){if(n!==e){if(!ec(e)&&!_a(e))var o=Ja(e);f(o||e,function(s,a){if(o&&(a=s,s=e[a]),ua(s))i||(i=new Xe),ar(n,e,a,t,sr,r,i);else{var u=r?r(n[a],s,a+"",n,e,i):X;u===X&&(u=s),ut(n,a,u)}})}}function ar(n,e,t,r,i,o,s){var a=n[t],u=e[t],l=s.get(u);if(l)return void ut(n,t,l);var f=o?o(a,u,t+"",n,e,s):X,c=f===X;c&&(f=u,ec(u)||_a(u)?ec(a)?f=a:Xs(a)?f=Xr(a):(c=!1,f=dt(u,!0)):va(u)||Gs(u)?Gs(a)?f=Ba(a):!ua(a)||r&&oa(a)?(c=!1,f=dt(u,!0)):f=a:c=!1),s.set(u,f),c&&i(f,u,r,o,s),s["delete"](u),ut(n,t,f)}function ur(n,e){var t=n.length;if(t)return e+=0>e?t:0,qi(e,t)?n[e]:X}function lr(n,e,t){var r=-1;e=m(e.length?e:[Du],j(Ti()));var i=rr(n,function(n,t,i){var o=m(e,function(e){return e(n)});return{criteria:o,index:++r,value:n}});return O(i,function(n,e){return Gr(n,e,t)})}function fr(n,e){return n=Object(n),v(e,function(e,t){return t in n&&(e[t]=n[t]),e},{})}function cr(n,e){for(var t=-1,r=_i(n),i=r.length,o={};++t<i;){var s=r[t],a=n[s];e(a,s)&&(o[s]=a)}return o}function hr(n){return function(e){return null==e?X:e[n]}}function pr(n){return function(e){return Ft(e,n)}}function dr(n,e,t,r){var i=r?_:E,o=-1,s=e.length,a=n;for(t&&(a=m(n,j(t)));++o<s;)for(var u=0,l=e[o],f=t?t(l):l;(u=i(a,f,u,r))>-1;)a!==n&&jl.call(a,u,1),jl.call(n,u,1);return n}function gr(n,e){for(var t=n?e.length:0,r=t-1;t--;){var i=e[t];if(t==r||i!==o){var o=i;if(qi(i))jl.call(n,i,1);else if(Hi(i,n))delete n[Zi(i)];else{var s=Cr(i),a=Ki(n,s);null!=a&&delete a[Zi(xo(s))]}}}return n}function mr(n,e){return n+Ll(ql()*(e-n+1))}function br(n,e,t,r){for(var i=-1,o=Dl(Bl((e-n)/(t||1)),0),s=Array(o);o--;)s[r?o:++i]=n,n+=t;return s}function vr(n,e){var t="";if(!n||1>e||e>En)return t;do e%2&&(t+=n),e=Ll(e/2),e&&(n+=n);while(e);return t}function yr(n,e,t,r){e=Hi(e,n)?[e]:Cr(e);for(var i=-1,o=e.length,s=o-1,a=n;null!=a&&++i<o;){var u=Zi(e[i]);if(ua(a)){var l=t;if(i!=s){var f=a[u];l=r?r(f,u,a):X,l===X&&(l=null==f?qi(e[i+1])?[]:{}:f)}lt(a,u,l)}a=a[u]}return n}function wr(n,e,t){var r=-1,i=n.length;0>e&&(e=-e>i?0:i+e),t=t>i?i:t,0>t&&(t+=i),i=e>t?0:t-e>>>0,e>>>=0;for(var o=Array(i);++r<i;)o[r]=n[r+e];return o}function xr(n,e){var t;return lf(n,function(n,r,i){return t=e(n,r,i),!t}),!!t}function kr(n,e,t){var r=0,i=n?n.length:r;if("number"==typeof e&&e===e&&An>=i){for(;i>r;){var o=r+i>>>1,s=n[o];null!==s&&!Ea(s)&&(t?e>=s:e>s)?r=o+1:i=o}return i}return Er(n,e,Du,t)}function Er(n,e,t,r){e=t(e);for(var i=0,o=n?n.length:0,s=e!==e,a=null===e,u=Ea(e),l=e===X;o>i;){var f=Ll((i+o)/2),c=t(n[f]),h=c!==X,p=null===c,d=c===c,g=Ea(c);if(s)var m=r||d;else m=l?d&&(r||h):a?d&&h&&(r||!p):u?d&&h&&!p&&(r||!g):p||g?!1:r?e>=c:e>c;m?i=f+1:o=f}return Fl(o,On)}function _r(n,e){for(var t=-1,r=n.length,i=0,o=[];++t<r;){var s=n[t],a=e?e(s):s;if(!t||!$s(a,u)){var u=a;o[i++]=0===s?0:s}}return o}function Sr(n){return"number"==typeof n?n:Ea(n)?Sn:+n}function Tr(n){if("string"==typeof n)return n;if(Ea(n))return uf?uf.call(n):"";var e=n+"";return"0"==e&&1/n==-kn?"-0":e}function Or(n,e,t){var r=-1,i=d,o=n.length,s=!0,a=[],u=a;if(t)s=!1,i=g;else if(o>=Q){var l=e?null:df(n);if(l)return Y(l);s=!1,i=Je,u=new Ge}else u=e?[]:a;n:for(;++r<o;){var f=n[r],c=e?e(f):f;if(f=t||0!==f?f:0,s&&c===c){for(var h=u.length;h--;)if(u[h]===c)continue n;e&&u.push(c),a.push(f)}else i(u,c,t)||(u!==a&&u.push(c),a.push(f))}return a}function Ar(n,e){e=Hi(e,n)?[e]:Cr(e),n=Ki(n,e);var t=Zi(xo(e));return!(null!=n&&Wt(n,t))||delete n[t]}function Rr(n,e,t,r){return yr(n,e,t(Ft(n,e)),r)}function Ir(n,e,t,r){for(var i=n.length,o=r?i:-1;(r?o--:++o<i)&&e(n[o],o,n););return t?wr(n,r?0:o,r?o+1:i):wr(n,r?o+1:0,r?i:o)}function jr(n,e){var t=n;return t instanceof i&&(t=t.value()),v(e,function(n,e){return e.func.apply(e.thisArg,b([n],e.args))},t)}function Br(n,e,t){for(var r=-1,i=n.length;++r<i;)var o=o?b(Ot(o,n[r],e,t),Ot(n[r],o,e,t)):n[r];return o&&o.length?Or(o,e,t):[]}function Lr(n,e,t){for(var r=-1,i=n.length,o=e.length,s={};++r<i;){var a=o>r?e[r]:X;t(s,n[r],a)}return s}function Pr(n){return Xs(n)?n:[]}function Nr(n){return"function"==typeof n?n:Du}function Cr(n){return ec(n)?n:yf(n)}function Mr(n,e,t){var r=n.length;return t=t===X?r:t,!e&&t>=r?n:wr(n,e,t)}function Dr(n,e){if(e)return n.slice();var t=new n.constructor(n.length);return n.copy(t),t}function Fr(n){var e=new n.constructor(n.byteLength);return new El(e).set(new El(n)),e}function Ur(n,e){var t=e?Fr(n.buffer):n.buffer;return new n.constructor(t,n.byteOffset,n.byteLength)}function qr(n,e,t){var r=e?t(H(n),!0):H(n);return v(r,o,new n.constructor)}function zr(n){var e=new n.constructor(n.source,_e.exec(n));return e.lastIndex=n.lastIndex,e}function Hr(n,e,t){var r=e?t(Y(n),!0):Y(n);return v(r,s,new n.constructor)}function Wr(n){return af?Object(af.call(n)):{}}function Yr(n,e){var t=e?Fr(n.buffer):n.buffer;return new n.constructor(t,n.byteOffset,n.length)}function $r(n,e){if(n!==e){var t=n!==X,r=null===n,i=n===n,o=Ea(n),s=e!==X,a=null===e,u=e===e,l=Ea(e);if(!a&&!l&&!o&&n>e||o&&s&&u&&!a&&!l||r&&s&&u||!t&&u||!i)return 1;if(!r&&!o&&!l&&e>n||l&&t&&i&&!r&&!o||a&&t&&i||!s&&i||!u)return-1}return 0}function Gr(n,e,t){for(var r=-1,i=n.criteria,o=e.criteria,s=i.length,a=t.length;++r<s;){var u=$r(i[r],o[r]);if(u){if(r>=a)return u;var l=t[r];return u*("desc"==l?-1:1)}}return n.index-e.index}function Jr(n,e,t,r){for(var i=-1,o=n.length,s=t.length,a=-1,u=e.length,l=Dl(o-s,0),f=Array(u+l),c=!r;++a<u;)f[a]=e[a];for(;++i<s;)(c||o>i)&&(f[t[i]]=n[i]);for(;l--;)f[a++]=n[i++];return f}function Vr(n,e,t,r){for(var i=-1,o=n.length,s=-1,a=t.length,u=-1,l=e.length,f=Dl(o-a,0),c=Array(f+l),h=!r;++i<f;)c[i]=n[i];for(var p=i;++u<l;)c[p+u]=e[u];for(;++s<a;)(h||o>i)&&(c[p+t[s]]=n[i++]);return c}function Xr(n,e){var t=-1,r=n.length;for(e||(e=Array(r));++t<r;)e[t]=n[t];return e}function Kr(n,e,t,r){t||(t={});for(var i=-1,o=e.length;++i<o;){var s=e[i],a=r?r(t[s],n[s],s,t,n):n[s];lt(t,s,a)}return t}function Qr(n,e){return Kr(n,ji(n),e)}function Zr(n,e){return function(t,r){var i=ec(t)?u:ft,o=e?e():{};return i(t,n,Ti(r),o)}}function ni(n){return Cs(function(e,t){var r=-1,i=t.length,o=i>1?t[i-1]:X,s=i>2?t[2]:X;for(o="function"==typeof o?(i--,o):X,s&&zi(t[0],t[1],s)&&(o=3>i?X:o,i=1),e=Object(e);++r<i;){var a=t[r];a&&n(e,a,r,o)}return e})}function ei(n,e){return function(t,r){if(null==t)return t;if(!Vs(t))return n(t,r);for(var i=t.length,o=e?i:-1,s=Object(t);(e?o--:++o<i)&&r(s[o],o,s)!==!1;);return t}}function ti(n){return function(e,t,r){for(var i=-1,o=Object(e),s=r(e),a=s.length;a--;){var u=s[n?a:++i];if(t(o[u],u,o)===!1)break}return e}}function ri(n,e,t){function r(){var e=this&&this!==qt&&this instanceof r?o:n;return e.apply(i?t:this,arguments)}var i=e&tn,o=si(n);return r}function ii(n){return function(e){e=Pa(e);var t=xt.test(e)?G(e):X,r=t?t[0]:e.charAt(0),i=t?Mr(t,1).join(""):e.slice(1);return r[n]()+i}}function oi(n){return function(e){return v(Pu(du(e).replace(bt,"")),n,"")}}function si(n){return function(){var e=arguments;switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3]);case 5:return new n(e[0],e[1],e[2],e[3],e[4]);case 6:return new n(e[0],e[1],e[2],e[3],e[4],e[5]);case 7:return new n(e[0],e[1],e[2],e[3],e[4],e[5],e[6])}var t=mt(n.prototype),r=n.apply(t,e);return ua(r)?r:t}}function ai(n,e,t){function r(){for(var o=arguments.length,s=Array(o),u=o,l=Ri(r);u--;)s[u]=arguments[u];var f=3>o&&s[0]!==l&&s[o-1]!==l?[]:W(s,l);if(o-=f.length,t>o)return bi(n,e,li,r.placeholder,X,s,f,X,X,t-o);var c=this&&this!==qt&&this instanceof r?i:n;return a(c,this,s)}var i=si(n);return r}function ui(n){return Cs(function(e){e=Pt(e,1);var t=e.length,i=t,o=r.prototype.thru;for(n&&e.reverse();i--;){var s=e[i];if("function"!=typeof s)throw new ll(Z);if(o&&!a&&"wrapper"==Si(s))var a=new r([],!0)}for(i=a?i:t;++i<t;){s=e[i];var u=Si(s),l="wrapper"==u?gf(s):X;a=l&&Yi(l[0])&&l[1]==(fn|sn|un|cn)&&!l[4].length&&1==l[9]?a[Si(l[0])].apply(a,l[3]):1==s.length&&Yi(s)?a[u]():a.thru(s)}return function(){var n=arguments,r=n[0];if(a&&1==n.length&&ec(r)&&r.length>=Q)return a.plant(r).value();for(var i=0,o=t?e[i].apply(this,n):r;++i<t;)o=e[i].call(this,o);return o}})}function li(n,e,t,r,i,o,s,a,u,l){function f(){for(var b=arguments.length,v=b,y=Array(b);v--;)y[v]=arguments[v];if(d)var w=Ri(f),x=C(y,w);if(r&&(y=Jr(y,r,i,d)),o&&(y=Vr(y,o,s,d)),b-=x,d&&l>b){var k=W(y,w);return bi(n,e,li,f.placeholder,t,y,k,a,u,l-b)}var E=h?t:this,_=p?E[n]:n;return b=y.length,a?y=Qi(y,a):g&&b>1&&y.reverse(),c&&b>u&&(y.length=u),this&&this!==qt&&this instanceof f&&(_=m||si(_)),_.apply(E,y)}var c=e&fn,h=e&tn,p=e&rn,d=e&(sn|an),g=e&hn,m=p?X:si(n);return f}function fi(n,e){return function(t,r){return Jt(t,n,e(r),{})}}function ci(n){return function(e,t){var r;if(e===X&&t===X)return 0;if(e!==X&&(r=e),t!==X){if(r===X)return t;"string"==typeof e||"string"==typeof t?(e=Tr(e),t=Tr(t)):(e=Sr(e),t=Sr(t)),r=n(e,t)}return r}}function hi(n){return Cs(function(e){return e=1==e.length&&ec(e[0])?m(e[0],j(Ti())):m(Pt(e,1,Ui),j(Ti())),Cs(function(t){var r=this;return n(e,function(n){return a(n,r,t)})})})}function pi(n,e){e=e===X?" ":Tr(e);var t=e.length;if(2>t)return t?vr(e,n):e;var r=vr(e,Bl(n/$(e)));return xt.test(e)?Mr(G(r),0,n).join(""):r.slice(0,n)}function di(n,e,t,r){function i(){for(var e=-1,u=arguments.length,l=-1,f=r.length,c=Array(f+u),h=this&&this!==qt&&this instanceof i?s:n;++l<f;)c[l]=r[l];for(;u--;)c[l++]=arguments[++e];return a(h,o?t:this,c)}var o=e&tn,s=si(n);return i}function gi(n){return function(e,t,r){return r&&"number"!=typeof r&&zi(e,t,r)&&(t=r=X),e=ja(e),e=e===e?e:0,t===X?(t=e,e=0):t=ja(t)||0,r=r===X?t>e?1:-1:ja(r)||0,br(e,t,r,n)}}function mi(n){return function(e,t){return("string"!=typeof e||"string"!=typeof t)&&(e=ja(e),t=ja(t)),n(e,t)}}function bi(n,e,t,r,i,o,s,a,u,l){var f=e&sn,c=f?s:X,h=f?X:s,p=f?o:X,d=f?X:o;e|=f?un:ln,e&=~(f?ln:un),e&on||(e&=~(tn|rn));var g=[n,e,i,p,c,d,h,a,u,l],m=t.apply(X,g);return Yi(n)&&vf(m,g),m.placeholder=r,m}function vi(n){var e=al[n];return function(n,t){if(n=ja(n),t=Ra(t)){var r=(Pa(n)+"e").split("e"),i=e(r[0]+"e"+(+r[1]+t));return r=(Pa(i)+"e").split("e"),+(r[0]+"e"+(+r[1]-t))}return e(n)}}function yi(n,e,t,r,i,o,s,a){var u=e&rn;if(!u&&"function"!=typeof n)throw new ll(Z);var l=r?r.length:0;if(l||(e&=~(un|ln),r=i=X),s=s===X?s:Dl(Ra(s),0),a=a===X?a:Ra(a),l-=i?i.length:0,e&ln){var f=r,c=i;r=i=X}var h=u?X:gf(n),p=[n,e,t,r,i,f,c,o,s,a];if(h&&Vi(p,h),n=p[0],e=p[1],t=p[2],r=p[3],i=p[4],a=p[9]=null==p[9]?u?0:n.length:Dl(p[9]-l,0),!a&&e&(sn|an)&&(e&=~(sn|an)),e&&e!=tn)d=e==sn||e==an?ai(n,e,a):e!=un&&e!=(tn|un)||i.length?li.apply(X,p):di(n,e,t,r);else var d=ri(n,e,t);var g=h?pf:vf;return g(d,p)}function wi(n,e,t,r,i,o){var s=-1,a=i&dn,u=i&pn,l=n.length,f=e.length;if(l!=f&&!(a&&f>l))return!1;var c=o.get(n);if(c)return c==e;var h=!0;for(o.set(n,e);++s<l;){var p=n[s],d=e[s];if(r)var g=a?r(d,p,s,e,n,o):r(p,d,s,n,e,o);if(g!==X){if(g)continue;h=!1;break}if(u){if(!w(e,function(n){return p===n||t(p,n,r,i,o)})){h=!1;break}}else if(p!==d&&!t(p,d,r,i,o)){h=!1;break}}return o["delete"](n),h}function xi(n,e,t,r,i,o,s){switch(t){case Gn:if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case $n:return n.byteLength==e.byteLength&&r(new El(n),new El(e))?!0:!1;case jn:case Bn:return+n==+e;case Ln:return n.name==e.name&&n.message==e.message;case Mn:return n!=+n?e!=+e:n==+e;case Un:case zn:return n==e+"";case Cn:var a=H;case qn:var u=o&dn;if(a||(a=Y),n.size!=e.size&&!u)return!1;var l=s.get(n);return l?l==e:(o|=pn,s.set(n,e),wi(a(n),a(e),r,i,o,s));case Hn:if(af)return af.call(n)==af.call(e)}return!1}function ki(n,e,t,r,i,o){var s=i&dn,a=Ga(n),u=a.length,l=Ga(e),f=l.length;if(u!=f&&!s)return!1;for(var c=u;c--;){var h=a[c];if(!(s?h in e:Wt(e,h)))return!1}var p=o.get(n);if(p)return p==e;var d=!0;o.set(n,e);for(var g=s;++c<u;){h=a[c];var m=n[h],b=e[h];if(r)var v=s?r(b,m,h,e,n,o):r(m,b,h,n,e,o);if(!(v===X?m===b||t(m,b,r,i,o):v)){d=!1;break}g||(g="constructor"==h)}if(d&&!g){var y=n.constructor,w=e.constructor;y!=w&&"constructor"in n&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof w&&w instanceof w)&&(d=!1)}return o["delete"](n),d}function Ei(n){return Ut(n,Ga,ji)}function _i(n){return Ut(n,Ja,bf)}function Si(n){for(var e=n.name+"",t=Zl[e],r=dl.call(Zl,e)?t.length:0;r--;){var i=t[r],o=i.func;if(null==o||o==n)return i.name}return e}function Ti(){var n=e.iteratee||Fu;return n=n===Fu?Zt:n,arguments.length?n(arguments[0],arguments[1]):n}function Oi(n){for(var e=tu(n),t=e.length;t--;)e[t][2]=Gi(e[t][1]);return e}function Ai(n,e){var t=n[e];return da(t)?t:X}function Ri(n){var t=dl.call(e,"placeholder")?e:n;return t.placeholder}function Ii(n){return Pl(Object(n))}function ji(n){return Tl(Object(n))}function Bi(n){return bl.call(n)}function Li(n,e,t){for(var r=-1,i=t.length;++r<i;){var o=t[r],s=o.size;switch(o.type){case"drop":n+=s;break;case"dropRight":e-=s;break;case"take":e=Fl(e,n+s);break;case"takeRight":n=Dl(n,e-s)}}return{start:n,end:e}}function Pi(n,e,t){e=Hi(e,n)?[e]:Cr(e);for(var r,i=-1,o=e.length;++i<o;){var s=Zi(e[i]);if(!(r=null!=n&&t(n,s)))break;n=n[s]}if(r)return r;var o=n?n.length:0;return!!o&&aa(o)&&qi(s,o)&&(ec(n)||ka(n)||Gs(n))}function Ni(n){var e=n.length,t=n.constructor(e);return e&&"string"==typeof n[0]&&dl.call(n,"index")&&(t.index=n.index,t.input=n.input),t}function Ci(n){return"function"!=typeof n.constructor||$i(n)?{}:mt(Ii(n))}function Mi(n,e,t,r){var i=n.constructor;switch(e){case $n:return Fr(n);case jn:case Bn:return new i(+n);case Gn:return Ur(n,r);case Jn:case Vn:case Xn:case Kn:case Qn:case Zn:case ne:case ee:case te:return Yr(n,r);case Cn:return qr(n,r,t);case Mn:case zn:return new i(n);case Un:return zr(n);case qn:return Hr(n,r,t);case Hn:return Wr(n)}}function Di(n){var e=n?n.length:X;return aa(e)&&(ec(n)||ka(n)||Gs(n))?R(e,String):null}function Fi(n){return Xs(n)&&(ec(n)||Gs(n))}function Ui(n){return ec(n)&&!(2==n.length&&!oa(n[0]))}function qi(n,e){return e=null==e?En:e,!!e&&("number"==typeof n||Ie.test(n))&&n>-1&&n%1==0&&e>n}function zi(n,e,t){if(!ua(t))return!1;var r=typeof e;return("number"==r?Vs(t)&&qi(e,t.length):"string"==r&&e in t)?$s(t[e],n):!1}function Hi(n,e){if(ec(n))return!1;var t=typeof n;return"number"==t||"symbol"==t||"boolean"==t||null==n||Ea(n)?!0:de.test(n)||!pe.test(n)||null!=e&&n in Object(e)}function Wi(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}function Yi(n){var t=Si(n),r=e[t];if("function"!=typeof r||!(t in i.prototype))return!1;if(n===r)return!0;var o=gf(r);return!!o&&n===o[0]}function $i(n){var e=n&&n.constructor,t="function"==typeof e&&e.prototype||cl;return n===t}function Gi(n){return n===n&&!ua(n)}function Ji(n,e){return function(t){return null==t?!1:t[n]===e&&(e!==X||n in Object(t))}}function Vi(n,e){var t=n[1],r=e[1],i=t|r,o=(tn|rn|fn)>i,s=r==fn&&t==sn||r==fn&&t==cn&&n[7].length<=e[8]||r==(fn|cn)&&e[7].length<=e[8]&&t==sn;if(!o&&!s)return n;r&tn&&(n[2]=e[2],i|=t&tn?0:on);var a=e[3];if(a){var u=n[3];n[3]=u?Jr(u,a,e[4]):a,n[4]=u?W(n[3],en):e[4]}return a=e[5],a&&(u=n[5],n[5]=u?Vr(u,a,e[6]):a,n[6]=u?W(n[5],en):e[6]),a=e[7],a&&(n[7]=a),r&fn&&(n[8]=null==n[8]?e[8]:Fl(n[8],e[8])),null==n[9]&&(n[9]=e[9]),n[0]=e[0],n[1]=i,n}function Xi(n,e,t,r,i,o){return ua(n)&&ua(e)&&sr(n,e,X,Xi,o.set(e,n)),n}function Ki(n,e){return 1==e.length?n:Ft(n,wr(e,0,-1))}function Qi(n,e){for(var t=n.length,r=Fl(e.length,t),i=Xr(n);r--;){var o=e[r];n[r]=qi(o,t)?i[o]:X}return n}function Zi(n){if("string"==typeof n||Ea(n))return n;var e=n+"";return"0"==e&&1/n==-kn?"-0":e}function no(n){if(null!=n){try{return pl.call(n)}catch(e){}try{return n+""}catch(e){}}return""}function eo(n){if(n instanceof i)return n.clone();var e=new r(n.__wrapped__,n.__chain__);return e.__actions__=Xr(n.__actions__),e.__index__=n.__index__,e.__values__=n.__values__,e}function to(n,e,t){e=(t?zi(n,e,t):e===X)?1:Dl(Ra(e),0);var r=n?n.length:0;if(!r||1>e)return[];for(var i=0,o=0,s=Array(Bl(r/e));r>i;)s[o++]=wr(n,i,i+=e);return s}function ro(n){for(var e=-1,t=n?n.length:0,r=0,i=[];++e<t;){var o=n[e];o&&(i[r++]=o)}return i}function io(){var n=arguments.length,e=qs(arguments[0]);if(2>n)return n?Xr(e):[];for(var t=Array(n-1);n--;)t[n-1]=arguments[n];return l(e,Pt(t,1))}function oo(n,e,t){var r=n?n.length:0;return r?(e=t||e===X?1:Ra(e),wr(n,0>e?0:e,r)):[]}function so(n,e,t){var r=n?n.length:0;return r?(e=t||e===X?1:Ra(e),e=r-e,wr(n,0,0>e?0:e)):[]}function ao(n,e){return n&&n.length?Ir(n,Ti(e,3),!0,!0):[]}function uo(n,e){return n&&n.length?Ir(n,Ti(e,3),!0):[]}function lo(n,e,t,r){var i=n?n.length:0;return i?(t&&"number"!=typeof t&&zi(n,e,t)&&(t=0,r=i),It(n,e,t,r)):[]}function fo(n,e){return n&&n.length?k(n,Ti(e,3)):-1}function co(n,e){return n&&n.length?k(n,Ti(e,3),!0):-1}function ho(n){var e=n?n.length:0;return e?Pt(n,1):[]}function po(n){var e=n?n.length:0;return e?Pt(n,kn):[]}function go(n,e){var t=n?n.length:0;return t?(e=e===X?1:Ra(e),Pt(n,e)):[]}function mo(n){for(var e=-1,t=n?n.length:0,r={};++e<t;){var i=n[e];r[i[0]]=i[1]}return r}function bo(n){return n&&n.length?n[0]:X}function vo(n,e,t){var r=n?n.length:0;return r?(t=Ra(t),0>t&&(t=Dl(r+t,0)),E(n,e,t)):-1}function yo(n){return so(n,1)}function wo(n,e){return n?Cl.call(n,e):""}function xo(n){var e=n?n.length:0;return e?n[e-1]:X}function ko(n,e,t){var r=n?n.length:0;if(!r)return-1;var i=r;if(t!==X&&(i=Ra(t),i=(0>i?Dl(r+i,0):Fl(i,r-1))+1),e!==e)return U(n,i,!0);for(;i--;)if(n[i]===e)return i;return-1}function Eo(n,e){return n&&n.length?ur(n,Ra(e)):X}function _o(n,e){return n&&n.length&&e&&e.length?dr(n,e):n}function So(n,e,t){return n&&n.length&&e&&e.length?dr(n,e,Ti(t)):n}function To(n,e,t){return n&&n.length&&e&&e.length?dr(n,e,X,t):n}function Oo(n,e){var t=[];if(!n||!n.length)return t;var r=-1,i=[],o=n.length;for(e=Ti(e,3);++r<o;){var s=n[r];e(s,r,n)&&(t.push(s),i.push(r))}return gr(n,i),t}function Ao(n){return n?Hl.call(n):n}function Ro(n,e,t){var r=n?n.length:0;return r?(t&&"number"!=typeof t&&zi(n,e,t)?(e=0,t=r):(e=null==e?0:Ra(e),t=t===X?r:Ra(t)),wr(n,e,t)):[]}function Io(n,e){return kr(n,e)}function jo(n,e,t){return Er(n,e,Ti(t))}function Bo(n,e){var t=n?n.length:0;if(t){var r=kr(n,e);if(t>r&&$s(n[r],e))return r}return-1}function Lo(n,e){return kr(n,e,!0)}function Po(n,e,t){return Er(n,e,Ti(t),!0)}function No(n,e){var t=n?n.length:0;if(t){var r=kr(n,e,!0)-1;if($s(n[r],e))return r}return-1}function Co(n){return n&&n.length?_r(n):[]}function Mo(n,e){return n&&n.length?_r(n,Ti(e)):[]}function Do(n){return oo(n,1)}function Fo(n,e,t){return n&&n.length?(e=t||e===X?1:Ra(e),wr(n,0,0>e?0:e)):[]}function Uo(n,e,t){var r=n?n.length:0;return r?(e=t||e===X?1:Ra(e),e=r-e,wr(n,0>e?0:e,r)):[]}function qo(n,e){return n&&n.length?Ir(n,Ti(e,3),!1,!0):[]}function zo(n,e){return n&&n.length?Ir(n,Ti(e,3)):[]}function Ho(n){return n&&n.length?Or(n):[]}function Wo(n,e){return n&&n.length?Or(n,Ti(e)):[]}function Yo(n,e){return n&&n.length?Or(n,X,e):[]}function $o(n){if(!n||!n.length)return[];var e=0;return n=p(n,function(n){return Xs(n)?(e=Dl(n.length,e),!0):void 0}),R(e,function(e){return m(n,hr(e))})}function Go(n,e){if(!n||!n.length)return[];var t=$o(n);return null==e?t:m(t,function(n){return a(e,X,n)})}function Jo(n,e){return Lr(n||[],e||[],lt)}function Vo(n,e){return Lr(n||[],e||[],yr)}function Xo(n){var t=e(n);return t.__chain__=!0,t}function Ko(n,e){return e(n),n}function Qo(n,e){return e(n)}function Zo(){return Xo(this)}function ns(){return new r(this.value(),this.__chain__)}function es(){this.__values__===X&&(this.__values__=Aa(this.value()));var n=this.__index__>=this.__values__.length,e=n?X:this.__values__[this.__index__++];return{done:n,value:e}}function ts(){return this}function rs(n){for(var e,r=this;r instanceof t;){var i=eo(r);i.__index__=0,i.__values__=X,e?o.__wrapped__=i:e=i;var o=i;r=r.__wrapped__}return o.__wrapped__=n,e}function is(){var n=this.__wrapped__;if(n instanceof i){var e=n;return this.__actions__.length&&(e=new i(this)),e=e.reverse(),e.__actions__.push({func:Qo,args:[Ao],thisArg:X}),new r(e,this.__chain__)}return this.thru(Ao)}function os(){return jr(this.__wrapped__,this.__actions__)}function ss(n,e,t){var r=ec(n)?h:At;return t&&zi(n,e,t)&&(e=X),r(n,Ti(e,3))}function as(n,e){var t=ec(n)?p:jt;return t(n,Ti(e,3))}function us(n,e){if(e=Ti(e,3),ec(n)){var t=k(n,e);return t>-1?n[t]:X}return x(n,e,lf)}function ls(n,e){if(e=Ti(e,3),ec(n)){var t=k(n,e,!0);return t>-1?n[t]:X}return x(n,e,ff)}function fs(n,e){return Pt(ms(n,e),1)}function cs(n,e){return Pt(ms(n,e),kn)}function hs(n,e,t){return t=t===X?1:Ra(t),Pt(ms(n,e),t)}function ps(n,e){return"function"==typeof e&&ec(n)?f(n,e):lf(n,Ti(e))}function ds(n,e){return"function"==typeof e&&ec(n)?c(n,e):ff(n,Ti(e))}function gs(n,e,t,r){n=Vs(n)?n:uu(n),t=t&&!r?Ra(t):0;var i=n.length;return 0>t&&(t=Dl(i+t,0)),ka(n)?i>=t&&n.indexOf(e,t)>-1:!!i&&E(n,e,t)>-1}function ms(n,e){var t=ec(n)?m:rr;return t(n,Ti(e,3))}function bs(n,e,t,r){return null==n?[]:(ec(e)||(e=null==e?[]:[e]),t=r?X:t,ec(t)||(t=null==t?[]:[t]),lr(n,e,t))}function vs(n,e,t){var r=ec(n)?v:T,i=arguments.length<3;return r(n,Ti(e,4),t,i,lf)}function ys(n,e,t){var r=ec(n)?y:T,i=arguments.length<3;return r(n,Ti(e,4),t,i,ff)}function ws(n,e){var t=ec(n)?p:jt;return e=Ti(e,3),t(n,function(n,t,r){return!e(n,t,r)})}function xs(n){var e=Vs(n)?n:uu(n),t=e.length;return t>0?e[mr(0,t-1)]:X}function ks(n,e,t){var r=-1,i=Aa(n),o=i.length,s=o-1;for(e=(t?zi(n,e,t):e===X)?1:pt(Ra(e),0,o);++r<e;){var a=mr(r,s),u=i[a];i[a]=i[r],i[r]=u}return i.length=e,i}function Es(n){return ks(n,Tn)}function _s(n){if(null==n)return 0;if(Vs(n)){var e=n.length;return e&&ka(n)?$(n):e}if(la(n)){var t=Bi(n);if(t==Cn||t==qn)return n.size}return Ga(n).length}function Ss(n,e,t){var r=ec(n)?w:xr;return t&&zi(n,e,t)&&(e=X),r(n,Ti(e,3))}function Ts(n,e){if("function"!=typeof e)throw new ll(Z);return n=Ra(n),function(){return--n<1?e.apply(this,arguments):void 0}}function Os(n,e,t){return e=t?X:e,e=n&&null==e?n.length:e,yi(n,fn,X,X,X,X,e)}function As(n,e){var t;if("function"!=typeof e)throw new ll(Z);return n=Ra(n),function(){return--n>0&&(t=e.apply(this,arguments)),1>=n&&(e=X),t}}function Rs(n,e,t){e=t?X:e;var r=yi(n,sn,X,X,X,X,X,e);return r.placeholder=Rs.placeholder,r}function Is(n,e,t){e=t?X:e;var r=yi(n,an,X,X,X,X,X,e);return r.placeholder=Is.placeholder,r}function js(n,e,t){function r(e){var t=h,r=p;return h=p=X,v=e,g=n.apply(r,t)}function i(n){return v=n,m=Il(a,e),y?r(n):g}function o(n){var t=n-b,r=n-v,i=e-t;return w?Fl(i,d-r):i}function s(n){var t=n-b,r=n-v;return!b||t>=e||0>t||w&&r>=d}function a(){var n=Wf();return s(n)?u(n):void(m=Il(a,o(n)))}function u(n){return _l(m),m=X,x&&h?r(n):(h=p=X,g)}function l(){m!==X&&_l(m),b=v=0,h=p=m=X}function f(){return m===X?g:u(Wf())}function c(){var n=Wf(),t=s(n);if(h=arguments,p=this,b=n,t){if(m===X)return i(b);if(w)return _l(m),m=Il(a,e),r(b)}return m===X&&(m=Il(a,e)),g}var h,p,d,g,m,b=0,v=0,y=!1,w=!1,x=!0;if("function"!=typeof n)throw new ll(Z);return e=ja(e)||0,ua(t)&&(y=!!t.leading,w="maxWait"in t,d=w?Dl(ja(t.maxWait)||0,e):d,x="trailing"in t?!!t.trailing:x),c.cancel=l,c.flush=f,c}function Bs(n){return yi(n,hn)}function Ls(n,e){if("function"!=typeof n||e&&"function"!=typeof e)throw new ll(Z);var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],o=t.cache;if(o.has(i))return o.get(i);var s=n.apply(this,r);return t.cache=o.set(i,s),s};return t.cache=new(Ls.Cache||qe),t}function Ps(n){if("function"!=typeof n)throw new ll(Z);return function(){return!n.apply(this,arguments)}}function Ns(n){return As(2,n)}function Cs(n,e){if("function"!=typeof n)throw new ll(Z);return e=Dl(e===X?n.length-1:Ra(e),0),function(){for(var t=arguments,r=-1,i=Dl(t.length-e,0),o=Array(i);++r<i;)o[r]=t[e+r];switch(e){case 0:return n.call(this,o);case 1:return n.call(this,t[0],o);case 2:return n.call(this,t[0],t[1],o)}var s=Array(e+1);for(r=-1;++r<e;)s[r]=t[r];return s[e]=o,a(n,this,s)}}function Ms(n,e){if("function"!=typeof n)throw new ll(Z);return e=e===X?0:Dl(Ra(e),0),Cs(function(t){var r=t[e],i=Mr(t,0,e);return r&&b(i,r),a(n,this,i)})}function Ds(n,e,t){var r=!0,i=!0;if("function"!=typeof n)throw new ll(Z);return ua(t)&&(r="leading"in t?!!t.leading:r,i="trailing"in t?!!t.trailing:i),js(n,e,{leading:r,maxWait:e,trailing:i})}function Fs(n){return Os(n,1)}function Us(n,e){return e=null==e?Du:e,Xf(e,n)}function qs(){if(!arguments.length)return[];var n=arguments[0];return ec(n)?n:[n]}function zs(n){return dt(n,!1,!0)}function Hs(n,e){return dt(n,!1,!0,e)}function Ws(n){return dt(n,!0,!0)}function Ys(n,e){return dt(n,!0,!0,e)}function $s(n,e){return n===e||n!==n&&e!==e}function Gs(n){return Xs(n)&&dl.call(n,"callee")&&(!Rl.call(n,"callee")||bl.call(n)==Rn)}function Js(n){return la(n)&&bl.call(n)==$n}function Vs(n){return null!=n&&aa(mf(n))&&!oa(n)}function Xs(n){return la(n)&&Vs(n)}function Ks(n){return n===!0||n===!1||la(n)&&bl.call(n)==jn}function Qs(n){return la(n)&&bl.call(n)==Bn}function Zs(n){return!!n&&1===n.nodeType&&la(n)&&!va(n)}function na(n){if(Vs(n)&&(ec(n)||ka(n)||oa(n.splice)||Gs(n)||tc(n)))return!n.length;if(la(n)){var e=Bi(n);if(e==Cn||e==qn)return!n.size}for(var t in n)if(dl.call(n,t))return!1;return!(Ql&&Ga(n).length)}function ea(n,e){return Xt(n,e)}function ta(n,e,t){t="function"==typeof t?t:X;var r=t?t(n,e):X;return r===X?Xt(n,e,t):!!r}function ra(n){return la(n)?bl.call(n)==Ln||"string"==typeof n.message&&"string"==typeof n.name:!1}function ia(n){return"number"==typeof n&&Nl(n)}function oa(n){var e=ua(n)?bl.call(n):"";return e==Pn||e==Nn}function sa(n){return"number"==typeof n&&n==Ra(n)}function aa(n){return"number"==typeof n&&n>-1&&n%1==0&&En>=n}function ua(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function la(n){return!!n&&"object"==typeof n}function fa(n){return la(n)&&Bi(n)==Cn}function ca(n,e){return n===e||Qt(n,e,Oi(e))}function ha(n,e,t){return t="function"==typeof t?t:X,Qt(n,e,Oi(e),t)}function pa(n){return ba(n)&&n!=+n}function da(n){if(!ua(n))return!1;var e=oa(n)||q(n)?yl:Ae;return e.test(no(n))}function ga(n){return null===n}function ma(n){return null==n}function ba(n){return"number"==typeof n||la(n)&&bl.call(n)==Mn}function va(n){if(!la(n)||bl.call(n)!=Dn||q(n))return!1;var e=Ii(n);if(null===e)return!0;var t=dl.call(e,"constructor")&&e.constructor;return"function"==typeof t&&t instanceof t&&pl.call(t)==ml}function ya(n){return ua(n)&&bl.call(n)==Un}function wa(n){return sa(n)&&n>=-En&&En>=n}function xa(n){return la(n)&&Bi(n)==qn}function ka(n){return"string"==typeof n||!ec(n)&&la(n)&&bl.call(n)==zn}function Ea(n){return"symbol"==typeof n||la(n)&&bl.call(n)==Hn}function _a(n){return la(n)&&aa(n.length)&&!!St[bl.call(n)]}function Sa(n){return n===X}function Ta(n){return la(n)&&Bi(n)==Wn}function Oa(n){return la(n)&&bl.call(n)==Yn}function Aa(n){if(!n)return[];if(Vs(n))return ka(n)?G(n):Xr(n);if(Ol&&n[Ol])return z(n[Ol]());var e=Bi(n),t=e==Cn?H:e==qn?Y:uu;return t(n)}function Ra(n){if(!n)return 0===n?n:0;if(n=ja(n),n===kn||n===-kn){var e=0>n?-1:1;return e*_n}var t=n%1;return n===n?t?n-t:n:0}function Ia(n){return n?pt(Ra(n),0,Tn):0}function ja(n){if("number"==typeof n)return n;if(Ea(n))return Sn;if(ua(n)){var e=oa(n.valueOf)?n.valueOf():n;n=ua(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(ve,"");var t=Oe.test(n);return t||Re.test(n)?Lt(n.slice(2),t?2:8):Te.test(n)?Sn:+n}function Ba(n){return Kr(n,Ja(n))}function La(n){return pt(Ra(n),-En,En)}function Pa(n){return null==n?"":Tr(n)}function Na(n,e){var t=mt(n);return e?ct(t,e):t}function Ca(n,e){return x(n,Ti(e,3),Nt,!0)}function Ma(n,e){return x(n,Ti(e,3),Mt,!0)}function Da(n,e){return null==n?n:cf(n,Ti(e),Ja)}function Fa(n,e){return null==n?n:hf(n,Ti(e),Ja)}function Ua(n,e){return n&&Nt(n,Ti(e))}function qa(n,e){return n&&Mt(n,Ti(e))}function za(n){return null==n?[]:Dt(n,Ga(n))}function Ha(n){return null==n?[]:Dt(n,Ja(n))}function Wa(n,e,t){var r=null==n?X:Ft(n,e);return r===X?t:r}function Ya(n,e){return null!=n&&Pi(n,e,Wt)}function $a(n,e){return null!=n&&Pi(n,e,Yt)}function Ga(n){var e=$i(n);if(!e&&!Vs(n))return nr(n);var t=Di(n),r=!!t,i=t||[],o=i.length;for(var s in n)!Wt(n,s)||r&&("length"==s||qi(s,o))||e&&"constructor"==s||i.push(s);return i}function Ja(n){for(var e=-1,t=$i(n),r=er(n),i=r.length,o=Di(n),s=!!o,a=o||[],u=a.length;++e<i;){var l=r[e];s&&("length"==l||qi(l,u))||"constructor"==l&&(t||!dl.call(n,l))||a.push(l)}return a}function Va(n,e){var t={};return e=Ti(e,3),Nt(n,function(n,r,i){t[e(n,r,i)]=n}),t}function Xa(n,e){var t={};return e=Ti(e,3),Nt(n,function(n,r,i){t[r]=e(n,r,i)}),t}function Ka(n,e){return e=Ti(e),cr(n,function(n,t){return!e(n,t)})}function Qa(n,e){return null==n?{}:cr(n,Ti(e))}function Za(n,e,t){e=Hi(e,n)?[e]:Cr(e);var r=-1,i=e.length;for(i||(n=X,i=1);++r<i;){var o=null==n?X:n[Zi(e[r])];o===X&&(r=i,o=t),n=oa(o)?o.call(n):o}return n}function nu(n,e,t){return null==n?n:yr(n,e,t)}function eu(n,e,t,r){return r="function"==typeof r?r:X,null==n?n:yr(n,e,t,r)}function tu(n){return I(n,Ga(n))}function ru(n){return I(n,Ja(n))}function iu(n,e,t){var r=ec(n)||_a(n);if(e=Ti(e,4),null==t)if(r||ua(n)){var i=n.constructor;t=r?ec(n)?new i:[]:oa(i)?mt(Ii(n)):{}}else t={};return(r?f:Nt)(n,function(n,r,i){return e(t,n,r,i)}),t}function ou(n,e){return null==n?!0:Ar(n,e)}function su(n,e,t){return null==n?n:Rr(n,e,Nr(t))}function au(n,e,t,r){return r="function"==typeof r?r:X,null==n?n:Rr(n,e,Nr(t),r)}function uu(n){return n?B(n,Ga(n)):[]}function lu(n){return null==n?[]:B(n,Ja(n))}function fu(n,e,t){return t===X&&(t=e,e=X),t!==X&&(t=ja(t),t=t===t?t:0),e!==X&&(e=ja(e),e=e===e?e:0),pt(ja(n),e,t)}function cu(n,e,t){return e=ja(e)||0,t===X?(t=e,e=0):t=ja(t)||0,n=ja(n),$t(n,e,t)}function hu(n,e,t){if(t&&"boolean"!=typeof t&&zi(n,e,t)&&(e=t=X),t===X&&("boolean"==typeof e?(t=e,e=X):"boolean"==typeof n&&(t=n,n=X)),n===X&&e===X?(n=0,e=1):(n=ja(n)||0,e===X?(e=n,n=0):e=ja(e)||0),n>e){var r=n;n=e,e=r}if(t||n%1||e%1){var i=ql();return Fl(n+i*(e-n+Bt("1e-"+((i+"").length-1))),e)}return mr(n,e)}function pu(n){return Tc(Pa(n).toLowerCase())}function du(n){return n=Pa(n),n&&n.replace(je,M).replace(vt,"")}function gu(n,e,t){n=Pa(n),e=Tr(e);var r=n.length;return t=t===X?r:pt(Ra(t),0,r),t-=e.length,t>=0&&n.indexOf(e,t)==t}function mu(n){return n=Pa(n),n&&le.test(n)?n.replace(ae,D):n}function bu(n){return n=Pa(n),n&&be.test(n)?n.replace(me,"\\$&"):n}function vu(n,e,t){n=Pa(n),e=Ra(e);var r=e?$(n):0;if(!e||r>=e)return n;var i=(e-r)/2;return pi(Ll(i),t)+n+pi(Bl(i),t)}function yu(n,e,t){n=Pa(n),e=Ra(e);var r=e?$(n):0;return e&&e>r?n+pi(e-r,t):n}function wu(n,e,t){n=Pa(n),e=Ra(e);var r=e?$(n):0;return e&&e>r?pi(e-r,t)+n:n}function xu(n,e,t){return t||null==e?e=0:e&&(e=+e),n=Pa(n).replace(ve,""),Ul(n,e||(Se.test(n)?16:10))}function ku(n,e,t){return e=(t?zi(n,e,t):e===X)?1:Ra(e),vr(Pa(n),e)}function Eu(){var n=arguments,e=Pa(n[0]);return n.length<3?e:zl.call(e,n[1],n[2])}function _u(n,e,t){return t&&"number"!=typeof t&&zi(n,e,t)&&(e=t=X),(t=t===X?Tn:t>>>0)?(n=Pa(n),n&&("string"==typeof e||null!=e&&!ya(e))&&(e=Tr(e),""==e&&xt.test(n))?Mr(G(n),0,t):Wl.call(n,e,t)):[]}function Su(n,e,t){return n=Pa(n),t=pt(Ra(t),0,n.length),n.lastIndexOf(Tr(e),t)==t}function Tu(n,t,r){
var i=e.templateSettings;r&&zi(n,t,r)&&(t=X),n=Pa(n),t=ac({},t,i,at);var o,s,a=ac({},t.imports,i.imports,at),u=Ga(a),l=B(a,u),f=0,c=t.interpolate||Be,h="__p += '",p=ul((t.escape||Be).source+"|"+c.source+"|"+(c===he?Ee:Be).source+"|"+(t.evaluate||Be).source+"|$","g"),d="//# sourceURL="+("sourceURL"in t?t.sourceURL:"lodash.templateSources["+ ++_t+"]")+"\n";n.replace(p,function(e,t,r,i,a,u){return r||(r=i),h+=n.slice(f,u).replace(Le,F),t&&(o=!0,h+="' +\n__e("+t+") +\n'"),a&&(s=!0,h+="';\n"+a+";\n__p += '"),r&&(h+="' +\n((__t = ("+r+")) == null ? '' : __t) +\n'"),f=u+e.length,e}),h+="';\n";var g=t.variable;g||(h="with (obj) {\n"+h+"\n}\n"),h=(s?h.replace(re,""):h).replace(ie,"$1").replace(oe,"$1;"),h="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(o?", __e = _.escape":"")+(s?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+h+"return __p\n}";var m=Oc(function(){return Function(u,d+"return "+h).apply(X,l)});if(m.source=h,ra(m))throw m;return m}function Ou(n){return Pa(n).toLowerCase()}function Au(n){return Pa(n).toUpperCase()}function Ru(n,e,t){if(n=Pa(n),n&&(t||e===X))return n.replace(ve,"");if(!n||!(e=Tr(e)))return n;var r=G(n),i=G(e),o=L(r,i),s=P(r,i)+1;return Mr(r,o,s).join("")}function Iu(n,e,t){if(n=Pa(n),n&&(t||e===X))return n.replace(we,"");if(!n||!(e=Tr(e)))return n;var r=G(n),i=P(r,G(e))+1;return Mr(r,0,i).join("")}function ju(n,e,t){if(n=Pa(n),n&&(t||e===X))return n.replace(ye,"");if(!n||!(e=Tr(e)))return n;var r=G(n),i=L(r,G(e));return Mr(r,i).join("")}function Bu(n,e){var t=gn,r=mn;if(ua(e)){var i="separator"in e?e.separator:i;t="length"in e?Ra(e.length):t,r="omission"in e?Tr(e.omission):r}n=Pa(n);var o=n.length;if(xt.test(n)){var s=G(n);o=s.length}if(t>=o)return n;var a=t-$(r);if(1>a)return r;var u=s?Mr(s,0,a).join(""):n.slice(0,a);if(i===X)return u+r;if(s&&(a+=u.length-a),ya(i)){if(n.slice(a).search(i)){var l,f=u;for(i.global||(i=ul(i.source,Pa(_e.exec(i))+"g")),i.lastIndex=0;l=i.exec(f);)var c=l.index;u=u.slice(0,c===X?a:c)}}else if(n.indexOf(Tr(i),a)!=a){var h=u.lastIndexOf(i);h>-1&&(u=u.slice(0,h))}return u+r}function Lu(n){return n=Pa(n),n&&ue.test(n)?n.replace(se,J):n}function Pu(n,e,t){return n=Pa(n),e=t?X:e,e===X&&(e=kt.test(n)?wt:xe),n.match(e)||[]}function Nu(n){var e=n?n.length:0,t=Ti();return n=e?m(n,function(n){if("function"!=typeof n[1])throw new ll(Z);return[t(n[0]),n[1]]}):[],Cs(function(t){for(var r=-1;++r<e;){var i=n[r];if(a(i[0],this,t))return a(i[1],this,t)}})}function Cu(n){return gt(dt(n,!0))}function Mu(n){return function(){return n}}function Du(n){return n}function Fu(n){return Zt("function"==typeof n?n:dt(n,!0))}function Uu(n){return ir(dt(n,!0))}function qu(n,e){return or(n,dt(e,!0))}function zu(n,e,t){var r=Ga(e),i=Dt(e,r);null!=t||ua(e)&&(i.length||!r.length)||(t=e,e=n,n=this,i=Dt(e,Ga(e)));var o=!(ua(t)&&"chain"in t&&!t.chain),s=oa(n);return f(i,function(t){var r=e[t];n[t]=r,s&&(n.prototype[t]=function(){var e=this.__chain__;if(o||e){var t=n(this.__wrapped__),i=t.__actions__=Xr(this.__actions__);return i.push({func:r,args:arguments,thisArg:n}),t.__chain__=e,t}return r.apply(n,b([this.value()],arguments))})}),n}function Hu(){return qt._===this&&(qt._=vl),this}function Wu(){}function Yu(n){return n=Ra(n),Cs(function(e){return ur(e,n)})}function $u(n){return Hi(n)?hr(Zi(n)):pr(n)}function Gu(n){return function(e){return null==n?X:Ft(n,e)}}function Ju(n,e){if(n=Ra(n),1>n||n>En)return[];var t=Tn,r=Fl(n,Tn);e=Ti(e),n-=Tn;for(var i=R(r,e);++t<n;)e(t);return i}function Vu(n){return ec(n)?m(n,Zi):Ea(n)?[n]:Xr(yf(n))}function Xu(n){var e=++gl;return Pa(n)+e}function Ku(n){return n&&n.length?Rt(n,Du,Ht):X}function Qu(n,e){return n&&n.length?Rt(n,Ti(e),Ht):X}function Zu(n){return S(n,Du)}function nl(n,e){return S(n,Ti(e))}function el(n){return n&&n.length?Rt(n,Du,tr):X}function tl(n,e){return n&&n.length?Rt(n,Ti(e),tr):X}function rl(n){return n&&n.length?A(n,Du):0}function il(n,e){return n&&n.length?A(n,Ti(e)):0}n=n?zt.defaults({},n,zt.pick(qt,Et)):qt;var ol=n.Date,sl=n.Error,al=n.Math,ul=n.RegExp,ll=n.TypeError,fl=n.Array.prototype,cl=n.Object.prototype,hl=n.String.prototype,pl=n.Function.prototype.toString,dl=cl.hasOwnProperty,gl=0,ml=pl.call(Object),bl=cl.toString,vl=qt._,yl=ul("^"+pl.call(dl).replace(me,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),wl=Ct?n.Buffer:X,xl=n.Reflect,kl=n.Symbol,El=n.Uint8Array,_l=n.clearTimeout,Sl=xl?xl.enumerate:X,Tl=Object.getOwnPropertySymbols,Ol="symbol"==typeof(Ol=kl&&kl.iterator)?Ol:X,Al=Object.create,Rl=cl.propertyIsEnumerable,Il=n.setTimeout,jl=fl.splice,Bl=al.ceil,Ll=al.floor,Pl=Object.getPrototypeOf,Nl=n.isFinite,Cl=fl.join,Ml=Object.keys,Dl=al.max,Fl=al.min,Ul=n.parseInt,ql=al.random,zl=hl.replace,Hl=fl.reverse,Wl=hl.split,Yl=Ai(n,"DataView"),$l=Ai(n,"Map"),Gl=Ai(n,"Promise"),Jl=Ai(n,"Set"),Vl=Ai(n,"WeakMap"),Xl=Ai(Object,"create"),Kl=Vl&&new Vl,Ql=!Rl.call({valueOf:1},"valueOf"),Zl={},nf=no(Yl),ef=no($l),tf=no(Gl),rf=no(Jl),of=no(Vl),sf=kl?kl.prototype:X,af=sf?sf.valueOf:X,uf=sf?sf.toString:X;e.templateSettings={escape:fe,evaluate:ce,interpolate:he,variable:"",imports:{_:e}},e.prototype=t.prototype,e.prototype.constructor=e,r.prototype=mt(t.prototype),r.prototype.constructor=r,i.prototype=mt(t.prototype),i.prototype.constructor=i,Ce.prototype=Xl?Xl(null):cl,qe.prototype.clear=ze,qe.prototype["delete"]=He,qe.prototype.get=We,qe.prototype.has=Ye,qe.prototype.set=$e,Ge.prototype.push=Ve,Xe.prototype.clear=Ke,Xe.prototype["delete"]=Qe,Xe.prototype.get=Ze,Xe.prototype.has=nt,Xe.prototype.set=et;var lf=ei(Nt),ff=ei(Mt,!0),cf=ti(),hf=ti(!0);Sl&&!Rl.call({valueOf:1},"valueOf")&&(er=function(n){return z(Sl(n))});var pf=Kl?function(n,e){return Kl.set(n,e),n}:Du,df=Jl&&1/Y(new Jl([,-0]))[1]==kn?function(n){return new Jl(n)}:Wu,gf=Kl?function(n){return Kl.get(n)}:Wu,mf=hr("length");Tl||(ji=function(){return[]});var bf=Tl?function(n){for(var e=[];n;)b(e,ji(n)),n=Ii(n);return e}:ji;(Yl&&Bi(new Yl(new ArrayBuffer(1)))!=Gn||$l&&Bi(new $l)!=Cn||Gl&&Bi(Gl.resolve())!=Fn||Jl&&Bi(new Jl)!=qn||Vl&&Bi(new Vl)!=Wn)&&(Bi=function(n){var e=bl.call(n),t=e==Dn?n.constructor:X,r=t?no(t):X;if(r)switch(r){case nf:return Gn;case ef:return Cn;case tf:return Fn;case rf:return qn;case of:return Wn}return e});var vf=function(){var n=0,e=0;return function(t,r){var i=Wf(),o=vn-(i-e);if(e=i,o>0){if(++n>=bn)return t}else n=0;return pf(t,r)}}(),yf=Ls(function(n){var e=[];return Pa(n).replace(ge,function(n,t,r,i){e.push(r?i.replace(ke,"$1"):t||n)}),e}),wf=Cs(function(n,e){return Xs(n)?Ot(n,Pt(e,1,Xs,!0)):[]}),xf=Cs(function(n,e){var t=xo(e);return Xs(t)&&(t=X),Xs(n)?Ot(n,Pt(e,1,Xs,!0),Ti(t)):[]}),kf=Cs(function(n,e){var t=xo(e);return Xs(t)&&(t=X),Xs(n)?Ot(n,Pt(e,1,Xs,!0),X,t):[]}),Ef=Cs(function(n){var e=m(n,Pr);return e.length&&e[0]===n[0]?Gt(e):[]}),_f=Cs(function(n){var e=xo(n),t=m(n,Pr);return e===xo(t)?e=X:t.pop(),t.length&&t[0]===n[0]?Gt(t,Ti(e)):[]}),Sf=Cs(function(n){var e=xo(n),t=m(n,Pr);return e===xo(t)?e=X:t.pop(),t.length&&t[0]===n[0]?Gt(t,X,e):[]}),Tf=Cs(_o),Of=Cs(function(n,e){e=Pt(e,1);var t=n?n.length:0,r=ht(n,e);return gr(n,m(e,function(n){return qi(n,t)?+n:n}).sort($r)),r}),Af=Cs(function(n){return Or(Pt(n,1,Xs,!0))}),Rf=Cs(function(n){var e=xo(n);return Xs(e)&&(e=X),Or(Pt(n,1,Xs,!0),Ti(e))}),If=Cs(function(n){var e=xo(n);return Xs(e)&&(e=X),Or(Pt(n,1,Xs,!0),X,e)}),jf=Cs(function(n,e){return Xs(n)?Ot(n,e):[]}),Bf=Cs(function(n){return Br(p(n,Xs))}),Lf=Cs(function(n){var e=xo(n);return Xs(e)&&(e=X),Br(p(n,Xs),Ti(e))}),Pf=Cs(function(n){var e=xo(n);return Xs(e)&&(e=X),Br(p(n,Xs),X,e)}),Nf=Cs($o),Cf=Cs(function(n){var e=n.length,t=e>1?n[e-1]:X;return t="function"==typeof t?(n.pop(),t):X,Go(n,t)}),Mf=Cs(function(n){n=Pt(n,1);var e=n.length,t=e?n[0]:0,o=this.__wrapped__,s=function(e){return ht(e,n)};return!(e>1||this.__actions__.length)&&o instanceof i&&qi(t)?(o=o.slice(t,+t+(e?1:0)),o.__actions__.push({func:Qo,args:[s],thisArg:X}),new r(o,this.__chain__).thru(function(n){return e&&!n.length&&n.push(X),n})):this.thru(s)}),Df=Zr(function(n,e,t){dl.call(n,t)?++n[t]:n[t]=1}),Ff=Zr(function(n,e,t){dl.call(n,t)?n[t].push(e):n[t]=[e]}),Uf=Cs(function(n,e,t){var r=-1,i="function"==typeof e,o=Hi(e),s=Vs(n)?Array(n.length):[];return lf(n,function(n){var u=i?e:o&&null!=n?n[e]:X;s[++r]=u?a(u,n,t):Vt(n,e,t)}),s}),qf=Zr(function(n,e,t){n[t]=e}),zf=Zr(function(n,e,t){n[t?0:1].push(e)},function(){return[[],[]]}),Hf=Cs(function(n,e){if(null==n)return[];var t=e.length;return t>1&&zi(n,e[0],e[1])?e=[]:t>2&&zi(e[0],e[1],e[2])&&(e=[e[0]]),e=1==e.length&&ec(e[0])?e[0]:Pt(e,1,Ui),lr(n,e,[])}),Wf=ol.now,Yf=Cs(function(n,e,t){var r=tn;if(t.length){var i=W(t,Ri(Yf));r|=un}return yi(n,r,e,t,i)}),$f=Cs(function(n,e,t){var r=tn|rn;if(t.length){var i=W(t,Ri($f));r|=un}return yi(e,r,n,t,i)}),Gf=Cs(function(n,e){return yt(n,1,e)}),Jf=Cs(function(n,e,t){return yt(n,ja(e)||0,t)});Ls.Cache=qe;var Vf=Cs(function(n,e){e=1==e.length&&ec(e[0])?m(e[0],j(Ti())):m(Pt(e,1,Ui),j(Ti()));var t=e.length;return Cs(function(r){for(var i=-1,o=Fl(r.length,t);++i<o;)r[i]=e[i].call(this,r[i]);return a(n,this,r)})}),Xf=Cs(function(n,e){var t=W(e,Ri(Xf));return yi(n,un,X,e,t)}),Kf=Cs(function(n,e){var t=W(e,Ri(Kf));return yi(n,ln,X,e,t)}),Qf=Cs(function(n,e){return yi(n,cn,X,X,X,Pt(e,1))}),Zf=mi(Ht),nc=mi(function(n,e){return n>=e}),ec=Array.isArray,tc=wl?function(n){return n instanceof wl}:Mu(!1),rc=mi(tr),ic=mi(function(n,e){return e>=n}),oc=ni(function(n,e){if(Ql||$i(e)||Vs(e))return void Kr(e,Ga(e),n);for(var t in e)dl.call(e,t)&&lt(n,t,e[t])}),sc=ni(function(n,e){if(Ql||$i(e)||Vs(e))return void Kr(e,Ja(e),n);for(var t in e)lt(n,t,e[t])}),ac=ni(function(n,e,t,r){Kr(e,Ja(e),n,r)}),uc=ni(function(n,e,t,r){Kr(e,Ga(e),n,r)}),lc=Cs(function(n,e){return ht(n,Pt(e,1))}),fc=Cs(function(n){return n.push(X,at),a(ac,X,n)}),cc=Cs(function(n){return n.push(X,Xi),a(mc,X,n)}),hc=fi(function(n,e,t){n[e]=t},Mu(Du)),pc=fi(function(n,e,t){dl.call(n,e)?n[e].push(t):n[e]=[t]},Ti),dc=Cs(Vt),gc=ni(function(n,e,t){sr(n,e,t)}),mc=ni(function(n,e,t,r){sr(n,e,t,r)}),bc=Cs(function(n,e){return null==n?{}:(e=m(Pt(e,1),Zi),fr(n,Ot(_i(n),e)))}),vc=Cs(function(n,e){return null==n?{}:fr(n,m(Pt(e,1),Zi))}),yc=oi(function(n,e,t){return e=e.toLowerCase(),n+(t?pu(e):e)}),wc=oi(function(n,e,t){return n+(t?"-":"")+e.toLowerCase()}),xc=oi(function(n,e,t){return n+(t?" ":"")+e.toLowerCase()}),kc=ii("toLowerCase"),Ec=oi(function(n,e,t){return n+(t?"_":"")+e.toLowerCase()}),_c=oi(function(n,e,t){return n+(t?" ":"")+Tc(e)}),Sc=oi(function(n,e,t){return n+(t?" ":"")+e.toUpperCase()}),Tc=ii("toUpperCase"),Oc=Cs(function(n,e){try{return a(n,X,e)}catch(t){return ra(t)?t:new sl(t)}}),Ac=Cs(function(n,e){return f(Pt(e,1),function(e){e=Zi(e),n[e]=Yf(n[e],n)}),n}),Rc=ui(),Ic=ui(!0),jc=Cs(function(n,e){return function(t){return Vt(t,n,e)}}),Bc=Cs(function(n,e){return function(t){return Vt(n,t,e)}}),Lc=hi(m),Pc=hi(h),Nc=hi(w),Cc=gi(),Mc=gi(!0),Dc=ci(function(n,e){return n+e}),Fc=vi("ceil"),Uc=ci(function(n,e){return n/e}),qc=vi("floor"),zc=ci(function(n,e){return n*e}),Hc=vi("round"),Wc=ci(function(n,e){return n-e});return e.after=Ts,e.ary=Os,e.assign=oc,e.assignIn=sc,e.assignInWith=ac,e.assignWith=uc,e.at=lc,e.before=As,e.bind=Yf,e.bindAll=Ac,e.bindKey=$f,e.castArray=qs,e.chain=Xo,e.chunk=to,e.compact=ro,e.concat=io,e.cond=Nu,e.conforms=Cu,e.constant=Mu,e.countBy=Df,e.create=Na,e.curry=Rs,e.curryRight=Is,e.debounce=js,e.defaults=fc,e.defaultsDeep=cc,e.defer=Gf,e.delay=Jf,e.difference=wf,e.differenceBy=xf,e.differenceWith=kf,e.drop=oo,e.dropRight=so,e.dropRightWhile=ao,e.dropWhile=uo,e.fill=lo,e.filter=as,e.flatMap=fs,e.flatMapDeep=cs,e.flatMapDepth=hs,e.flatten=ho,e.flattenDeep=po,e.flattenDepth=go,e.flip=Bs,e.flow=Rc,e.flowRight=Ic,e.fromPairs=mo,e.functions=za,e.functionsIn=Ha,e.groupBy=Ff,e.initial=yo,e.intersection=Ef,e.intersectionBy=_f,e.intersectionWith=Sf,e.invert=hc,e.invertBy=pc,e.invokeMap=Uf,e.iteratee=Fu,e.keyBy=qf,e.keys=Ga,e.keysIn=Ja,e.map=ms,e.mapKeys=Va,e.mapValues=Xa,e.matches=Uu,e.matchesProperty=qu,e.memoize=Ls,e.merge=gc,e.mergeWith=mc,e.method=jc,e.methodOf=Bc,e.mixin=zu,e.negate=Ps,e.nthArg=Yu,e.omit=bc,e.omitBy=Ka,e.once=Ns,e.orderBy=bs,e.over=Lc,e.overArgs=Vf,e.overEvery=Pc,e.overSome=Nc,e.partial=Xf,e.partialRight=Kf,e.partition=zf,e.pick=vc,e.pickBy=Qa,e.property=$u,e.propertyOf=Gu,e.pull=Tf,e.pullAll=_o,e.pullAllBy=So,e.pullAllWith=To,e.pullAt=Of,e.range=Cc,e.rangeRight=Mc,e.rearg=Qf,e.reject=ws,e.remove=Oo,e.rest=Cs,e.reverse=Ao,e.sampleSize=ks,e.set=nu,e.setWith=eu,e.shuffle=Es,e.slice=Ro,e.sortBy=Hf,e.sortedUniq=Co,e.sortedUniqBy=Mo,e.split=_u,e.spread=Ms,e.tail=Do,e.take=Fo,e.takeRight=Uo,e.takeRightWhile=qo,e.takeWhile=zo,e.tap=Ko,e.throttle=Ds,e.thru=Qo,e.toArray=Aa,e.toPairs=tu,e.toPairsIn=ru,e.toPath=Vu,e.toPlainObject=Ba,e.transform=iu,e.unary=Fs,e.union=Af,e.unionBy=Rf,e.unionWith=If,e.uniq=Ho,e.uniqBy=Wo,e.uniqWith=Yo,e.unset=ou,e.unzip=$o,e.unzipWith=Go,e.update=su,e.updateWith=au,e.values=uu,e.valuesIn=lu,e.without=jf,e.words=Pu,e.wrap=Us,e.xor=Bf,e.xorBy=Lf,e.xorWith=Pf,e.zip=Nf,e.zipObject=Jo,e.zipObjectDeep=Vo,e.zipWith=Cf,e.entries=tu,e.entriesIn=ru,e.extend=sc,e.extendWith=ac,zu(e,e),e.add=Dc,e.attempt=Oc,e.camelCase=yc,e.capitalize=pu,e.ceil=Fc,e.clamp=fu,e.clone=zs,e.cloneDeep=Ws,e.cloneDeepWith=Ys,e.cloneWith=Hs,e.deburr=du,e.divide=Uc,e.endsWith=gu,e.eq=$s,e.escape=mu,e.escapeRegExp=bu,e.every=ss,e.find=us,e.findIndex=fo,e.findKey=Ca,e.findLast=ls,e.findLastIndex=co,e.findLastKey=Ma,e.floor=qc,e.forEach=ps,e.forEachRight=ds,e.forIn=Da,e.forInRight=Fa,e.forOwn=Ua,e.forOwnRight=qa,e.get=Wa,e.gt=Zf,e.gte=nc,e.has=Ya,e.hasIn=$a,e.head=bo,e.identity=Du,e.includes=gs,e.indexOf=vo,e.inRange=cu,e.invoke=dc,e.isArguments=Gs,e.isArray=ec,e.isArrayBuffer=Js,e.isArrayLike=Vs,e.isArrayLikeObject=Xs,e.isBoolean=Ks,e.isBuffer=tc,e.isDate=Qs,e.isElement=Zs,e.isEmpty=na,e.isEqual=ea,e.isEqualWith=ta,e.isError=ra,e.isFinite=ia,e.isFunction=oa,e.isInteger=sa,e.isLength=aa,e.isMap=fa,e.isMatch=ca,e.isMatchWith=ha,e.isNaN=pa,e.isNative=da,e.isNil=ma,e.isNull=ga,e.isNumber=ba,e.isObject=ua,e.isObjectLike=la,e.isPlainObject=va,e.isRegExp=ya,e.isSafeInteger=wa,e.isSet=xa,e.isString=ka,e.isSymbol=Ea,e.isTypedArray=_a,e.isUndefined=Sa,e.isWeakMap=Ta,e.isWeakSet=Oa,e.join=wo,e.kebabCase=wc,e.last=xo,e.lastIndexOf=ko,e.lowerCase=xc,e.lowerFirst=kc,e.lt=rc,e.lte=ic,e.max=Ku,e.maxBy=Qu,e.mean=Zu,e.meanBy=nl,e.min=el,e.minBy=tl,e.multiply=zc,e.nth=Eo,e.noConflict=Hu,e.noop=Wu,e.now=Wf,e.pad=vu,e.padEnd=yu,e.padStart=wu,e.parseInt=xu,e.random=hu,e.reduce=vs,e.reduceRight=ys,e.repeat=ku,e.replace=Eu,e.result=Za,e.round=Hc,e.runInContext=V,e.sample=xs,e.size=_s,e.snakeCase=Ec,e.some=Ss,e.sortedIndex=Io,e.sortedIndexBy=jo,e.sortedIndexOf=Bo,e.sortedLastIndex=Lo,e.sortedLastIndexBy=Po,e.sortedLastIndexOf=No,e.startCase=_c,e.startsWith=Su,e.subtract=Wc,e.sum=rl,e.sumBy=il,e.template=Tu,e.times=Ju,e.toInteger=Ra,e.toLength=Ia,e.toLower=Ou,e.toNumber=ja,e.toSafeInteger=La,e.toString=Pa,e.toUpper=Au,e.trim=Ru,e.trimEnd=Iu,e.trimStart=ju,e.truncate=Bu,e.unescape=Lu,e.uniqueId=Xu,e.upperCase=Sc,e.upperFirst=Tc,e.each=ps,e.eachRight=ds,e.first=bo,zu(e,function(){var n={};return Nt(e,function(t,r){dl.call(e.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),e.VERSION=K,f(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){e[n].placeholder=e}),f(["drop","take"],function(n,e){i.prototype[n]=function(t){var r=this.__filtered__;if(r&&!e)return new i(this);t=t===X?1:Dl(Ra(t),0);var o=this.clone();return r?o.__takeCount__=Fl(t,o.__takeCount__):o.__views__.push({size:Fl(t,Tn),type:n+(o.__dir__<0?"Right":"")}),o},i.prototype[n+"Right"]=function(e){return this.reverse()[n](e).reverse()}}),f(["filter","map","takeWhile"],function(n,e){var t=e+1,r=t==yn||t==xn;i.prototype[n]=function(n){var e=this.clone();return e.__iteratees__.push({iteratee:Ti(n,3),type:t}),e.__filtered__=e.__filtered__||r,e}}),f(["head","last"],function(n,e){var t="take"+(e?"Right":"");i.prototype[n]=function(){return this[t](1).value()[0]}}),f(["initial","tail"],function(n,e){var t="drop"+(e?"":"Right");i.prototype[n]=function(){return this.__filtered__?new i(this):this[t](1)}}),i.prototype.compact=function(){return this.filter(Du)},i.prototype.find=function(n){return this.filter(n).head()},i.prototype.findLast=function(n){return this.reverse().find(n)},i.prototype.invokeMap=Cs(function(n,e){return"function"==typeof n?new i(this):this.map(function(t){return Vt(t,n,e)})}),i.prototype.reject=function(n){return n=Ti(n,3),this.filter(function(e){return!n(e)})},i.prototype.slice=function(n,e){n=Ra(n);var t=this;return t.__filtered__&&(n>0||0>e)?new i(t):(0>n?t=t.takeRight(-n):n&&(t=t.drop(n)),e!==X&&(e=Ra(e),t=0>e?t.dropRight(-e):t.take(e-n)),t)},i.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},i.prototype.toArray=function(){return this.take(Tn)},Nt(i.prototype,function(n,t){var o=/^(?:filter|find|map|reject)|While$/.test(t),s=/^(?:head|last)$/.test(t),a=e[s?"take"+("last"==t?"Right":""):t],u=s||/^find/.test(t);a&&(e.prototype[t]=function(){var t=this.__wrapped__,l=s?[1]:arguments,f=t instanceof i,c=l[0],h=f||ec(t),p=function(n){var t=a.apply(e,b([n],l));return s&&d?t[0]:t};h&&o&&"function"==typeof c&&1!=c.length&&(f=h=!1);var d=this.__chain__,g=!!this.__actions__.length,m=u&&!d,v=f&&!g;if(!u&&h){t=v?t:new i(this);var y=n.apply(t,l);return y.__actions__.push({func:Qo,args:[p],thisArg:X}),new r(y,d)}return m&&v?n.apply(this,l):(y=this.thru(p),m?s?y.value()[0]:y.value():y)})}),f(["pop","push","shift","sort","splice","unshift"],function(n){var t=fl[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",i=/^(?:pop|shift)$/.test(n);e.prototype[n]=function(){var n=arguments;if(i&&!this.__chain__){var e=this.value();return t.apply(ec(e)?e:[],n)}return this[r](function(e){return t.apply(ec(e)?e:[],n)})}}),Nt(i.prototype,function(n,t){var r=e[t];if(r){var i=r.name+"",o=Zl[i]||(Zl[i]=[]);o.push({name:t,func:r})}}),Zl[li(X,rn).name]=[{name:"wrapper",func:X}],i.prototype.clone=N,i.prototype.reverse=Pe,i.prototype.value=Ne,e.prototype.at=Mf,e.prototype.chain=Zo,e.prototype.commit=ns,e.prototype.next=es,e.prototype.plant=rs,e.prototype.reverse=is,e.prototype.toJSON=e.prototype.valueOf=e.prototype.value=os,Ol&&(e.prototype[Ol]=ts),e}var X,K="4.11.2",Q=200,Z="Expected a function",nn="__lodash_hash_undefined__",en="__lodash_placeholder__",tn=1,rn=2,on=4,sn=8,an=16,un=32,ln=64,fn=128,cn=256,hn=512,pn=1,dn=2,gn=30,mn="...",bn=150,vn=16,yn=1,wn=2,xn=3,kn=1/0,En=9007199254740991,_n=1.7976931348623157e308,Sn=NaN,Tn=4294967295,On=Tn-1,An=Tn>>>1,Rn="[object Arguments]",In="[object Array]",jn="[object Boolean]",Bn="[object Date]",Ln="[object Error]",Pn="[object Function]",Nn="[object GeneratorFunction]",Cn="[object Map]",Mn="[object Number]",Dn="[object Object]",Fn="[object Promise]",Un="[object RegExp]",qn="[object Set]",zn="[object String]",Hn="[object Symbol]",Wn="[object WeakMap]",Yn="[object WeakSet]",$n="[object ArrayBuffer]",Gn="[object DataView]",Jn="[object Float32Array]",Vn="[object Float64Array]",Xn="[object Int8Array]",Kn="[object Int16Array]",Qn="[object Int32Array]",Zn="[object Uint8Array]",ne="[object Uint8ClampedArray]",ee="[object Uint16Array]",te="[object Uint32Array]",re=/\b__p \+= '';/g,ie=/\b(__p \+=) '' \+/g,oe=/(__e\(.*?\)|\b__t\)) \+\n'';/g,se=/&(?:amp|lt|gt|quot|#39|#96);/g,ae=/[&<>"'`]/g,ue=RegExp(se.source),le=RegExp(ae.source),fe=/<%-([\s\S]+?)%>/g,ce=/<%([\s\S]+?)%>/g,he=/<%=([\s\S]+?)%>/g,pe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,de=/^\w*$/,ge=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]/g,me=/[\\^$.*+?()[\]{}|]/g,be=RegExp(me.source),ve=/^\s+|\s+$/g,ye=/^\s+/,we=/\s+$/,xe=/[a-zA-Z0-9]+/g,ke=/\\(\\)?/g,Ee=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,_e=/\w*$/,Se=/^0x/i,Te=/^[-+]0x[0-9a-f]+$/i,Oe=/^0b[01]+$/i,Ae=/^\[object .+?Constructor\]$/,Re=/^0o[0-7]+$/i,Ie=/^(?:0|[1-9]\d*)$/,je=/[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g,Be=/($^)/,Le=/['\n\r\u2028\u2029\\]/g,Pe="\\ud800-\\udfff",Ne="\\u0300-\\u036f\\ufe20-\\ufe23",Ce="\\u20d0-\\u20f0",Me="\\u2700-\\u27bf",De="a-z\\xdf-\\xf6\\xf8-\\xff",Fe="\\xac\\xb1\\xd7\\xf7",Ue="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",qe="\\u2000-\\u206f",ze=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",He="A-Z\\xc0-\\xd6\\xd8-\\xde",We="\\ufe0e\\ufe0f",Ye=Fe+Ue+qe+ze,$e="[']",Ge="["+Pe+"]",Je="["+Ye+"]",Ve="["+Ne+Ce+"]",Xe="\\d+",Ke="["+Me+"]",Qe="["+De+"]",Ze="[^"+Pe+Ye+Xe+Me+De+He+"]",nt="\\ud83c[\\udffb-\\udfff]",et="(?:"+Ve+"|"+nt+")",tt="[^"+Pe+"]",rt="(?:\\ud83c[\\udde6-\\uddff]){2}",it="[\\ud800-\\udbff][\\udc00-\\udfff]",ot="["+He+"]",st="\\u200d",at="(?:"+Qe+"|"+Ze+")",ut="(?:"+ot+"|"+Ze+")",lt="(?:"+$e+"(?:d|ll|m|re|s|t|ve))?",ft="(?:"+$e+"(?:D|LL|M|RE|S|T|VE))?",ct=et+"?",ht="["+We+"]?",pt="(?:"+st+"(?:"+[tt,rt,it].join("|")+")"+ht+ct+")*",dt=ht+ct+pt,gt="(?:"+[Ke,rt,it].join("|")+")"+dt,mt="(?:"+[tt+Ve+"?",Ve,rt,it,Ge].join("|")+")",bt=RegExp($e,"g"),vt=RegExp(Ve,"g"),yt=RegExp(nt+"(?="+nt+")|"+mt+dt,"g"),wt=RegExp([ot+"?"+Qe+"+"+lt+"(?="+[Je,ot,"$"].join("|")+")",ut+"+"+ft+"(?="+[Je,ot+at,"$"].join("|")+")",ot+"?"+at+"+"+lt,ot+"+"+ft,Xe,gt].join("|"),"g"),xt=RegExp("["+st+Pe+Ne+Ce+We+"]"),kt=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,Et=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","Reflect","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],_t=-1,St={};St[Jn]=St[Vn]=St[Xn]=St[Kn]=St[Qn]=St[Zn]=St[ne]=St[ee]=St[te]=!0,St[Rn]=St[In]=St[$n]=St[jn]=St[Gn]=St[Bn]=St[Ln]=St[Pn]=St[Cn]=St[Mn]=St[Dn]=St[Un]=St[qn]=St[zn]=St[Wn]=!1;var Tt={};Tt[Rn]=Tt[In]=Tt[$n]=Tt[Gn]=Tt[jn]=Tt[Bn]=Tt[Jn]=Tt[Vn]=Tt[Xn]=Tt[Kn]=Tt[Qn]=Tt[Cn]=Tt[Mn]=Tt[Dn]=Tt[Un]=Tt[qn]=Tt[zn]=Tt[Hn]=Tt[Zn]=Tt[ne]=Tt[ee]=Tt[te]=!0,Tt[Ln]=Tt[Pn]=Tt[Wn]=!1;var Ot={"":"A","":"A","":"A","":"A","":"A","":"A","":"a","":"a","":"a","":"a","":"a","":"a","":"C","":"c","":"D","":"d","":"E","":"E","":"E","":"E","":"e","":"e","":"e","":"e","":"I","":"I","":"I","":"I","":"i","":"i","":"i","":"i","":"N","":"n","":"O","":"O","":"O","":"O","":"O","":"O","":"o","":"o","":"o","":"o","":"o","":"o","":"U","":"U","":"U","":"U","":"u","":"u","":"u","":"u","":"Y","":"y","":"y","":"Ae","":"ae","":"Th","":"th","":"ss"},At={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#96;"},Rt={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'","&#96;":"`"},It={"function":!0,object:!0},jt={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Bt=parseFloat,Lt=parseInt,Pt=It[typeof e]&&e&&!e.nodeType?e:X,Nt=It[typeof n]&&n&&!n.nodeType?n:X,Ct=Nt&&Nt.exports===Pt?Pt:X,Mt=N(Pt&&Nt&&"object"==typeof i&&i),Dt=N(It[typeof self]&&self),Ft=N(It[typeof window]&&window),Ut=N(It[typeof this]&&this),qt=Mt||Ft!==(Ut&&Ut.window)&&Ft||Dt||Ut||Function("return this")(),zt=V();(Ft||Dt||{})._=zt,r=function(){return zt}.call(e,t,e,n),!(r!==X&&(n.exports=r))}).call(this)}).call(e,t(10)(n),function(){return this}())},function(n,e,t){var r=t(22);"string"==typeof r&&(r=[[n.id,r,""]]);t(3)(r,{});r.locals&&(n.exports=r.locals)},function(n,e,t){var r=t(23);"string"==typeof r&&(r=[[n.id,r,""]]);t(3)(r,{});r.locals&&(n.exports=r.locals)},function(n,e,t){var r=t(24);"string"==typeof r&&(r=[[n.id,r,""]]);t(3)(r,{});r.locals&&(n.exports=r.locals)},function(n,e,t){var r=t(25);"string"==typeof r&&(r=[[n.id,r,""]]);t(3)(r,{});r.locals&&(n.exports=r.locals)},function(n,e,t){function r(n){return t(i(n))}function i(n){return o[n]||function(){throw new Error("Cannot find module '"+n+"'.")}()}var o={"./app/app.css":13,"./editor/editor.css":31,"./gutter/gutter.css":32,"./tab/tab.css":33,"./tree/tree.css":34};r.keys=function(){return Object.keys(o)},r.resolve=i,n.exports=r,r.id=35},function(n,e,t){function r(n){return t(i(n))}function i(n){return o[n]||function(){throw new Error("Cannot find module '"+n+"'.")}()}var o={"./app/app.html":11,"./editor/editor.html":26,"./gutter/gutter.html":27,"./tab/tab.html":28,"./tree/tree.html":29};r.keys=function(){return Object.keys(o)},r.resolve=i,n.exports=r,r.id=36},,function(n,e){/*!
	 * Chai - getActual utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e){return e.length>4?e[4]:n._obj}},function(n,e){/*!
	 * Chai - getName utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n){if(n.name)return n.name;var e=/^\s?function ([^(]*)\(/.exec(n);return e&&e[1]?e[1]:""}},function(n,e,t){/*!
	 * ## parsePath(path)
	 *
	 * Helper function used to parse string object
	 * paths. Use in conjunction with `_getPathValue`.
	 *
	 *      var parsed = parsePath('myobject.property.subprop');
	 *
	 * ### Paths:
	 *
	 * * Can be as near infinitely deep and nested
	 * * Arrays are also valid using the formal `myobject.document[3].property`.
	 * * Literal dots and brackets (not delimiter) must be backslash-escaped.
	 *
	 * @param {String} path
	 * @returns {Object} parsed
	 * @api private
	 */
function r(n){var e=n.replace(/([^\\])\[/g,"$1.["),t=e.match(/(\\\.|[^.]+?)+/g);return t.map(function(n){var e=/^\[(\d+)\]$/,t=e.exec(n);return t?{i:parseFloat(t[1])}:{p:n.replace(/\\([.\[\]])/g,"$1")}})}/*!
	 * ## _getPathValue(parsed, obj)
	 *
	 * Helper companion function for `.parsePath` that returns
	 * the value located at the parsed address.
	 *
	 *      var value = getPathValue(parsed, obj);
	 *
	 * @param {Object} parsed definition from `parsePath`.
	 * @param {Object} object to search against
	 * @param {Number} object to search against
	 * @returns {Object|Undefined} value
	 * @api private
	 */
function i(n,e,t){var r,i=e;t=void 0===t?n.length:t;for(var o=0,s=t;s>o;o++){var a=n[o];i?("undefined"!=typeof a.p?i=i[a.p]:"undefined"!=typeof a.i&&(i=i[a.i]),o==s-1&&(r=i)):r=void 0}return r}/*!
	 * Chai - getPathInfo utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var o=t(41);n.exports=function(n,e){var t=r(n),s=t[t.length-1],a={parent:t.length>1?i(t,e,t.length-1):e,name:s.p||s.i,value:i(t,e)};return a.exists=o(a.name,a.parent),a}},function(n,e,t){/*!
	 * Chai - hasProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=t(20),i={number:Number,string:String};n.exports=function(n,e){var t=r(e);return"null"===t||"undefined"===t?!1:(i[t]&&"object"!=typeof e&&(e=new i[t](e)),n in e)}},function(n,e,t){/*!
	 * Chai - flag utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Module dependancies
	 */
var r=t(19),i=t(8);n.exports=function(n){var e=r(n),t=Object.prototype.toString.call(n);if(i.truncateThreshold&&e.length>=i.truncateThreshold){if("[object Function]"===t)return n.name&&""!==n.name?"[Function: "+n.name+"]":"[Function]";if("[object Array]"===t)return"[ Array("+n.length+") ]";if("[object Object]"===t){var o=Object.keys(n),s=o.length>2?o.splice(0,2).join(", ")+", ...":o.join(", ");return"{ Object ("+s+") }"}return e}return e}},function(n,e){/*!
	 * Chai - transferFlags utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e,t){var r=n.__flags||(n.__flags=Object.create(null));e.__flags||(e.__flags=Object.create(null)),t=3===arguments.length?t:!0;for(var i in r)(t||"object"!==i&&"ssfi"!==i&&"message"!=i)&&(e.__flags[i]=r[i])}},function(n,e){/*!
	 * assertion-error
	 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
	 * MIT Licensed
	 */
/*!
	 * Return a function that will copy properties from
	 * one object to another excluding any originally
	 * listed. Returned function will create a new `{}`.
	 *
	 * @param {String} excluded properties ...
	 * @return {Function}
	 */
function t(){function n(n,t){Object.keys(t).forEach(function(r){~e.indexOf(r)||(n[r]=t[r])})}var e=[].slice.call(arguments);return function(){for(var e=[].slice.call(arguments),t=0,r={};t<e.length;t++)n(r,e[t]);return r}}function r(n,e,r){var i=t("name","message","stack","constructor","toJSON"),o=i(e||{});this.message=n||"Unspecified AssertionError",this.showDiff=!1;for(var s in o)this[s]=o[s];r=r||arguments.callee,r&&Error.captureStackTrace?Error.captureStackTrace(this,r):this.stack=(new Error).stack}/*!
	 * Primary Exports
	 */
n.exports=r,/*!
	 * Inherit from Error.prototype
	 */
r.prototype=Object.create(Error.prototype),/*!
	 * Statically set name
	 */
r.prototype.name="AssertionError",/*!
	 * Ensure correct constructor
	 */
r.prototype.constructor=r,r.prototype.toJSON=function(n){var e=t("constructor","toJSON","stack"),r=e({name:this.name},this);return!1!==n&&this.stack&&(r.stack=this.stack),r}},function(n,e,t){(function(n,r){/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
"use strict";function i(){function n(){}try{var e=new Uint8Array(1);return e.foo=function(){return 42},e.constructor=n,42===e.foo()&&e.constructor===n&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(t){return!1}}function o(){return n.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function n(e){return this instanceof n?(n.TYPED_ARRAY_SUPPORT||(this.length=0,this.parent=void 0),"number"==typeof e?s(this,e):"string"==typeof e?a(this,e,arguments.length>1?arguments[1]:"utf8"):u(this,e)):arguments.length>1?new n(e,arguments[1]):new n(e)}function s(e,t){if(e=g(e,0>t?0:0|m(t)),!n.TYPED_ARRAY_SUPPORT)for(var r=0;t>r;r++)e[r]=0;return e}function a(n,e,t){("string"!=typeof t||""===t)&&(t="utf8");var r=0|v(e,t);return n=g(n,r),n.write(e,t),n}function u(e,t){if(n.isBuffer(t))return l(e,t);if(X(t))return f(e,t);if(null==t)throw new TypeError("must start with number, buffer, array or string");if("undefined"!=typeof ArrayBuffer){if(t.buffer instanceof ArrayBuffer)return c(e,t);if(t instanceof ArrayBuffer)return h(e,t)}return t.length?p(e,t):d(e,t)}function l(n,e){var t=0|m(e.length);return n=g(n,t),e.copy(n,0,0,t),n}function f(n,e){var t=0|m(e.length);n=g(n,t);for(var r=0;t>r;r+=1)n[r]=255&e[r];return n}function c(n,e){var t=0|m(e.length);n=g(n,t);for(var r=0;t>r;r+=1)n[r]=255&e[r];return n}function h(e,t){return n.TYPED_ARRAY_SUPPORT?(t.byteLength,e=n._augment(new Uint8Array(t))):e=c(e,new Uint8Array(t)),e}function p(n,e){var t=0|m(e.length);n=g(n,t);for(var r=0;t>r;r+=1)n[r]=255&e[r];return n}function d(n,e){var t,r=0;"Buffer"===e.type&&X(e.data)&&(t=e.data,r=0|m(t.length)),n=g(n,r);for(var i=0;r>i;i+=1)n[i]=255&t[i];return n}function g(e,t){n.TYPED_ARRAY_SUPPORT?(e=n._augment(new Uint8Array(t)),e.__proto__=n.prototype):(e.length=t,e._isBuffer=!0);var r=0!==t&&t<=n.poolSize>>>1;return r&&(e.parent=K),e}function m(n){if(n>=o())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+o().toString(16)+" bytes");return 0|n}function b(e,t){if(!(this instanceof b))return new b(e,t);var r=new n(e,t);return delete r.parent,r}function v(n,e){"string"!=typeof n&&(n=""+n);var t=n.length;if(0===t)return 0;for(var r=!1;;)switch(e){case"ascii":case"binary":case"raw":case"raws":return t;case"utf8":case"utf-8":return H(n).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*t;case"hex":return t>>>1;case"base64":return $(n).length;default:if(r)return H(n).length;e=(""+e).toLowerCase(),r=!0}}function y(n,e,t){var r=!1;if(e=0|e,t=void 0===t||t===1/0?this.length:0|t,n||(n="utf8"),0>e&&(e=0),t>this.length&&(t=this.length),e>=t)return"";for(;;)switch(n){case"hex":return j(this,e,t);case"utf8":case"utf-8":return O(this,e,t);case"ascii":return R(this,e,t);case"binary":return I(this,e,t);case"base64":return T(this,e,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return B(this,e,t);default:if(r)throw new TypeError("Unknown encoding: "+n);n=(n+"").toLowerCase(),r=!0}}function w(n,e,t,r){t=Number(t)||0;var i=n.length-t;r?(r=Number(r),r>i&&(r=i)):r=i;var o=e.length;if(o%2!==0)throw new Error("Invalid hex string");r>o/2&&(r=o/2);for(var s=0;r>s;s++){var a=parseInt(e.substr(2*s,2),16);if(isNaN(a))throw new Error("Invalid hex string");n[t+s]=a}return s}function x(n,e,t,r){return G(H(e,n.length-t),n,t,r)}function k(n,e,t,r){return G(W(e),n,t,r)}function E(n,e,t,r){return k(n,e,t,r)}function _(n,e,t,r){return G($(e),n,t,r)}function S(n,e,t,r){return G(Y(e,n.length-t),n,t,r)}function T(n,e,t){return 0===e&&t===n.length?J.fromByteArray(n):J.fromByteArray(n.slice(e,t))}function O(n,e,t){t=Math.min(n.length,t);for(var r=[],i=e;t>i;){var o=n[i],s=null,a=o>239?4:o>223?3:o>191?2:1;if(t>=i+a){var u,l,f,c;switch(a){case 1:128>o&&(s=o);break;case 2:u=n[i+1],128===(192&u)&&(c=(31&o)<<6|63&u,c>127&&(s=c));break;case 3:u=n[i+1],l=n[i+2],128===(192&u)&&128===(192&l)&&(c=(15&o)<<12|(63&u)<<6|63&l,c>2047&&(55296>c||c>57343)&&(s=c));break;case 4:u=n[i+1],l=n[i+2],f=n[i+3],128===(192&u)&&128===(192&l)&&128===(192&f)&&(c=(15&o)<<18|(63&u)<<12|(63&l)<<6|63&f,c>65535&&1114112>c&&(s=c))}}null===s?(s=65533,a=1):s>65535&&(s-=65536,r.push(s>>>10&1023|55296),s=56320|1023&s),r.push(s),i+=a}return A(r)}function A(n){var e=n.length;if(Q>=e)return String.fromCharCode.apply(String,n);for(var t="",r=0;e>r;)t+=String.fromCharCode.apply(String,n.slice(r,r+=Q));return t}function R(n,e,t){var r="";t=Math.min(n.length,t);for(var i=e;t>i;i++)r+=String.fromCharCode(127&n[i]);return r}function I(n,e,t){var r="";t=Math.min(n.length,t);for(var i=e;t>i;i++)r+=String.fromCharCode(n[i]);return r}function j(n,e,t){var r=n.length;(!e||0>e)&&(e=0),(!t||0>t||t>r)&&(t=r);for(var i="",o=e;t>o;o++)i+=z(n[o]);return i}function B(n,e,t){for(var r=n.slice(e,t),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function L(n,e,t){if(n%1!==0||0>n)throw new RangeError("offset is not uint");if(n+e>t)throw new RangeError("Trying to access beyond buffer length")}function P(e,t,r,i,o,s){if(!n.isBuffer(e))throw new TypeError("buffer must be a Buffer instance");if(t>o||s>t)throw new RangeError("value is out of bounds");if(r+i>e.length)throw new RangeError("index out of range")}function N(n,e,t,r){0>e&&(e=65535+e+1);for(var i=0,o=Math.min(n.length-t,2);o>i;i++)n[t+i]=(e&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function C(n,e,t,r){0>e&&(e=4294967295+e+1);for(var i=0,o=Math.min(n.length-t,4);o>i;i++)n[t+i]=e>>>8*(r?i:3-i)&255}function M(n,e,t,r,i,o){if(e>i||o>e)throw new RangeError("value is out of bounds");if(t+r>n.length)throw new RangeError("index out of range");if(0>t)throw new RangeError("index out of range")}function D(n,e,t,r,i){return i||M(n,e,t,4,3.4028234663852886e38,-3.4028234663852886e38),V.write(n,e,t,r,23,4),t+4}function F(n,e,t,r,i){return i||M(n,e,t,8,1.7976931348623157e308,-1.7976931348623157e308),V.write(n,e,t,r,52,8),t+8}function U(n){if(n=q(n).replace(nn,""),n.length<2)return"";for(;n.length%4!==0;)n+="=";return n}function q(n){return n.trim?n.trim():n.replace(/^\s+|\s+$/g,"")}function z(n){return 16>n?"0"+n.toString(16):n.toString(16)}function H(n,e){e=e||1/0;for(var t,r=n.length,i=null,o=[],s=0;r>s;s++){if(t=n.charCodeAt(s),t>55295&&57344>t){if(!i){if(t>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===r){(e-=3)>-1&&o.push(239,191,189);continue}i=t;continue}if(56320>t){(e-=3)>-1&&o.push(239,191,189),i=t;continue}t=(i-55296<<10|t-56320)+65536}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,128>t){if((e-=1)<0)break;o.push(t)}else if(2048>t){if((e-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(65536>t){if((e-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(1114112>t))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function W(n){for(var e=[],t=0;t<n.length;t++)e.push(255&n.charCodeAt(t));return e}function Y(n,e){for(var t,r,i,o=[],s=0;s<n.length&&!((e-=2)<0);s++)t=n.charCodeAt(s),r=t>>8,i=t%256,o.push(i),o.push(r);return o}function $(n){return J.toByteArray(U(n))}function G(n,e,t,r){for(var i=0;r>i&&!(i+t>=e.length||i>=n.length);i++)e[i+t]=n[i];return i}var J=t(95),V=t(96),X=t(97);e.Buffer=n,e.SlowBuffer=b,e.INSPECT_MAX_BYTES=50,n.poolSize=8192;var K={};n.TYPED_ARRAY_SUPPORT=void 0!==r.TYPED_ARRAY_SUPPORT?r.TYPED_ARRAY_SUPPORT:i(),n.TYPED_ARRAY_SUPPORT?(n.prototype.__proto__=Uint8Array.prototype,n.__proto__=Uint8Array):(n.prototype.length=void 0,n.prototype.parent=void 0),n.isBuffer=function(n){return!(null==n||!n._isBuffer)},n.compare=function(e,t){if(!n.isBuffer(e)||!n.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,i=t.length,o=0,s=Math.min(r,i);s>o&&e[o]===t[o];)++o;return o!==s&&(r=e[o],i=t[o]),i>r?-1:r>i?1:0},n.isEncoding=function(n){switch(String(n).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"raw":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},n.concat=function(e,t){if(!X(e))throw new TypeError("list argument must be an Array of Buffers.");if(0===e.length)return new n(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;r++)t+=e[r].length;var i=new n(t),o=0;for(r=0;r<e.length;r++){var s=e[r];s.copy(i,o),o+=s.length}return i},n.byteLength=v,n.prototype.toString=function(){var n=0|this.length;return 0===n?"":0===arguments.length?O(this,0,n):y.apply(this,arguments)},n.prototype.equals=function(e){if(!n.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?!0:0===n.compare(this,e)},n.prototype.inspect=function(){var n="",t=e.INSPECT_MAX_BYTES;return this.length>0&&(n=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(n+=" ... ")),"<Buffer "+n+">"},n.prototype.compare=function(e){if(!n.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e?0:n.compare(this,e)},n.prototype.indexOf=function(e,t){function r(n,e,t){for(var r=-1,i=0;t+i<n.length;i++)if(n[t+i]===e[-1===r?0:i-r]){if(-1===r&&(r=i),i-r+1===e.length)return t+r}else r=-1;return-1}if(t>2147483647?t=2147483647:-2147483648>t&&(t=-2147483648),t>>=0,0===this.length)return-1;if(t>=this.length)return-1;if(0>t&&(t=Math.max(this.length+t,0)),"string"==typeof e)return 0===e.length?-1:String.prototype.indexOf.call(this,e,t);if(n.isBuffer(e))return r(this,e,t);if("number"==typeof e)return n.TYPED_ARRAY_SUPPORT&&"function"===Uint8Array.prototype.indexOf?Uint8Array.prototype.indexOf.call(this,e,t):r(this,[e],t);throw new TypeError("val must be string, number or Buffer")},n.prototype.get=function(n){return console.log(".get() is deprecated. Access using array indexes instead."),this.readUInt8(n)},n.prototype.set=function(n,e){return console.log(".set() is deprecated. Access using array indexes instead."),this.writeUInt8(n,e)},n.prototype.write=function(n,e,t,r){if(void 0===e)r="utf8",t=this.length,e=0;else if(void 0===t&&"string"==typeof e)r=e,t=this.length,e=0;else if(isFinite(e))e=0|e,isFinite(t)?(t=0|t,void 0===r&&(r="utf8")):(r=t,t=void 0);else{var i=r;r=e,e=0|t,t=i}var o=this.length-e;if((void 0===t||t>o)&&(t=o),n.length>0&&(0>t||0>e)||e>this.length)throw new RangeError("attempt to write outside buffer bounds");r||(r="utf8");for(var s=!1;;)switch(r){case"hex":return w(this,n,e,t);case"utf8":case"utf-8":return x(this,n,e,t);case"ascii":return k(this,n,e,t);case"binary":return E(this,n,e,t);case"base64":return _(this,n,e,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return S(this,n,e,t);default:if(s)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),s=!0}},n.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var Q=4096;n.prototype.slice=function(e,t){var r=this.length;e=~~e,t=void 0===t?r:~~t,0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),e>t&&(t=e);var i;if(n.TYPED_ARRAY_SUPPORT)i=n._augment(this.subarray(e,t));else{var o=t-e;i=new n(o,void 0);for(var s=0;o>s;s++)i[s]=this[s+e]}return i.length&&(i.parent=this.parent||this),i},n.prototype.readUIntLE=function(n,e,t){n=0|n,e=0|e,t||L(n,e,this.length);for(var r=this[n],i=1,o=0;++o<e&&(i*=256);)r+=this[n+o]*i;return r},n.prototype.readUIntBE=function(n,e,t){n=0|n,e=0|e,t||L(n,e,this.length);for(var r=this[n+--e],i=1;e>0&&(i*=256);)r+=this[n+--e]*i;return r},n.prototype.readUInt8=function(n,e){return e||L(n,1,this.length),this[n]},n.prototype.readUInt16LE=function(n,e){return e||L(n,2,this.length),this[n]|this[n+1]<<8},n.prototype.readUInt16BE=function(n,e){return e||L(n,2,this.length),this[n]<<8|this[n+1]},n.prototype.readUInt32LE=function(n,e){return e||L(n,4,this.length),(this[n]|this[n+1]<<8|this[n+2]<<16)+16777216*this[n+3]},n.prototype.readUInt32BE=function(n,e){return e||L(n,4,this.length),16777216*this[n]+(this[n+1]<<16|this[n+2]<<8|this[n+3])},n.prototype.readIntLE=function(n,e,t){n=0|n,e=0|e,t||L(n,e,this.length);for(var r=this[n],i=1,o=0;++o<e&&(i*=256);)r+=this[n+o]*i;return i*=128,r>=i&&(r-=Math.pow(2,8*e)),r},n.prototype.readIntBE=function(n,e,t){n=0|n,e=0|e,t||L(n,e,this.length);for(var r=e,i=1,o=this[n+--r];r>0&&(i*=256);)o+=this[n+--r]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},n.prototype.readInt8=function(n,e){return e||L(n,1,this.length),128&this[n]?-1*(255-this[n]+1):this[n]},n.prototype.readInt16LE=function(n,e){e||L(n,2,this.length);var t=this[n]|this[n+1]<<8;return 32768&t?4294901760|t:t},n.prototype.readInt16BE=function(n,e){e||L(n,2,this.length);var t=this[n+1]|this[n]<<8;return 32768&t?4294901760|t:t},n.prototype.readInt32LE=function(n,e){return e||L(n,4,this.length),this[n]|this[n+1]<<8|this[n+2]<<16|this[n+3]<<24},n.prototype.readInt32BE=function(n,e){return e||L(n,4,this.length),this[n]<<24|this[n+1]<<16|this[n+2]<<8|this[n+3]},n.prototype.readFloatLE=function(n,e){return e||L(n,4,this.length),V.read(this,n,!0,23,4)},n.prototype.readFloatBE=function(n,e){return e||L(n,4,this.length),V.read(this,n,!1,23,4)},n.prototype.readDoubleLE=function(n,e){return e||L(n,8,this.length),V.read(this,n,!0,52,8)},n.prototype.readDoubleBE=function(n,e){return e||L(n,8,this.length),V.read(this,n,!1,52,8)},n.prototype.writeUIntLE=function(n,e,t,r){n=+n,e=0|e,t=0|t,r||P(this,n,e,t,Math.pow(2,8*t),0);var i=1,o=0;for(this[e]=255&n;++o<t&&(i*=256);)this[e+o]=n/i&255;return e+t},n.prototype.writeUIntBE=function(n,e,t,r){n=+n,e=0|e,t=0|t,r||P(this,n,e,t,Math.pow(2,8*t),0);var i=t-1,o=1;for(this[e+i]=255&n;--i>=0&&(o*=256);)this[e+i]=n/o&255;return e+t},n.prototype.writeUInt8=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,1,255,0),n.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},n.prototype.writeUInt16LE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,2,65535,0),n.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},n.prototype.writeUInt16BE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,2,65535,0),n.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},n.prototype.writeUInt32LE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,4,4294967295,0),n.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):C(this,e,t,!0),t+4},n.prototype.writeUInt32BE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,4,4294967295,0),n.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):C(this,e,t,!1),t+4},n.prototype.writeIntLE=function(n,e,t,r){if(n=+n,e=0|e,!r){var i=Math.pow(2,8*t-1);P(this,n,e,t,i-1,-i)}var o=0,s=1,a=0>n?1:0;for(this[e]=255&n;++o<t&&(s*=256);)this[e+o]=(n/s>>0)-a&255;return e+t},n.prototype.writeIntBE=function(n,e,t,r){if(n=+n,e=0|e,!r){var i=Math.pow(2,8*t-1);P(this,n,e,t,i-1,-i)}var o=t-1,s=1,a=0>n?1:0;for(this[e+o]=255&n;--o>=0&&(s*=256);)this[e+o]=(n/s>>0)-a&255;return e+t},n.prototype.writeInt8=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,1,127,-128),n.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),0>e&&(e=255+e+1),this[t]=255&e,t+1},n.prototype.writeInt16LE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,2,32767,-32768),n.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},n.prototype.writeInt16BE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,2,32767,-32768),n.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},n.prototype.writeInt32LE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,4,2147483647,-2147483648),n.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):C(this,e,t,!0),t+4},n.prototype.writeInt32BE=function(e,t,r){return e=+e,t=0|t,r||P(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),n.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):C(this,e,t,!1),t+4},n.prototype.writeFloatLE=function(n,e,t){return D(this,n,e,!0,t)},n.prototype.writeFloatBE=function(n,e,t){return D(this,n,e,!1,t)},n.prototype.writeDoubleLE=function(n,e,t){return F(this,n,e,!0,t)},n.prototype.writeDoubleBE=function(n,e,t){return F(this,n,e,!1,t)},n.prototype.copy=function(e,t,r,i){if(r||(r=0),i||0===i||(i=this.length),t>=e.length&&(t=e.length),t||(t=0),i>0&&r>i&&(i=r),i===r)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError("targetStart out of bounds");if(0>r||r>=this.length)throw new RangeError("sourceStart out of bounds");if(0>i)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length),e.length-t<i-r&&(i=e.length-t+r);var o,s=i-r;if(this===e&&t>r&&i>t)for(o=s-1;o>=0;o--)e[o+t]=this[o+r];else if(1e3>s||!n.TYPED_ARRAY_SUPPORT)for(o=0;s>o;o++)e[o+t]=this[o+r];else e._set(this.subarray(r,r+s),t);return s},n.prototype.fill=function(n,e,t){if(n||(n=0),e||(e=0),t||(t=this.length),e>t)throw new RangeError("end < start");if(t!==e&&0!==this.length){if(0>e||e>=this.length)throw new RangeError("start out of bounds");if(0>t||t>this.length)throw new RangeError("end out of bounds");var r;if("number"==typeof n)for(r=e;t>r;r++)this[r]=n;else{var i=H(n.toString()),o=i.length;for(r=e;t>r;r++)this[r]=i[r%o]}return this}},n.prototype.toArrayBuffer=function(){if("undefined"!=typeof Uint8Array){if(n.TYPED_ARRAY_SUPPORT)return new n(this).buffer;for(var e=new Uint8Array(this.length),t=0,r=e.length;r>t;t+=1)e[t]=this[t];return e.buffer}throw new TypeError("Buffer.toArrayBuffer not supported in this browser")};var Z=n.prototype;n._augment=function(e){return e.constructor=n,e._isBuffer=!0,e._set=e.set,e.get=Z.get,e.set=Z.set,e.write=Z.write,e.toString=Z.toString,e.toLocaleString=Z.toString,e.toJSON=Z.toJSON,e.equals=Z.equals,e.compare=Z.compare,e.indexOf=Z.indexOf,e.copy=Z.copy,e.slice=Z.slice,e.readUIntLE=Z.readUIntLE,e.readUIntBE=Z.readUIntBE,e.readUInt8=Z.readUInt8,e.readUInt16LE=Z.readUInt16LE,e.readUInt16BE=Z.readUInt16BE,e.readUInt32LE=Z.readUInt32LE,e.readUInt32BE=Z.readUInt32BE,e.readIntLE=Z.readIntLE,e.readIntBE=Z.readIntBE,e.readInt8=Z.readInt8,e.readInt16LE=Z.readInt16LE,e.readInt16BE=Z.readInt16BE,e.readInt32LE=Z.readInt32LE,e.readInt32BE=Z.readInt32BE,e.readFloatLE=Z.readFloatLE,e.readFloatBE=Z.readFloatBE,e.readDoubleLE=Z.readDoubleLE,e.readDoubleBE=Z.readDoubleBE,e.writeUInt8=Z.writeUInt8,e.writeUIntLE=Z.writeUIntLE,e.writeUIntBE=Z.writeUIntBE,e.writeUInt16LE=Z.writeUInt16LE,e.writeUInt16BE=Z.writeUInt16BE,e.writeUInt32LE=Z.writeUInt32LE,e.writeUInt32BE=Z.writeUInt32BE,e.writeIntLE=Z.writeIntLE,e.writeIntBE=Z.writeIntBE,e.writeInt8=Z.writeInt8,e.writeInt16LE=Z.writeInt16LE,e.writeInt16BE=Z.writeInt16BE,e.writeInt32LE=Z.writeInt32LE,e.writeInt32BE=Z.writeInt32BE,e.writeFloatLE=Z.writeFloatLE,e.writeFloatBE=Z.writeFloatBE,e.writeDoubleLE=Z.writeDoubleLE,e.writeDoubleBE=Z.writeDoubleBE,e.fill=Z.fill,e.inspect=Z.inspect,e.toArrayBuffer=Z.toArrayBuffer,e};var nn=/[^+\/0-9A-Za-z-_]/g}).call(e,t(45).Buffer,function(){return this}())},,,,,,,,,,,,,,function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{"default":n}}var i=t(18),o=r(i),s=t(60).assert,a=t(30),u={tab:[{name:"app.js",active:!0},{name:"test.css",active:!1},{name:"log.js",active:!1}]};describe("Array of tab :",function(){describe("Function getIndexTabByName",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u)),it("should return at least 1",function(){s.isAtLeast(n._getIndexTabByName("test.css"),1)}),it("should return -1",function(){s.strictEqual(n._getIndexTabByName("wrong.css"),-1)})}),describe("Function getIndexActiveTab",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u)),it("should return index 0",function(){s.strictEqual(n._getIndexActiveTab(),0)})}),describe("Function deleteTabByIndex",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u));var e=n.oData.tab.length,t=n._getIndexTabByName("test.css");it("should return index 1 (function getIndexTabByName)",function(){s.isAtLeast(t,1)}),it("delete tab and return object with length equal to "+(e-1),function(){n._deleteTabByIndex(t),s.lengthOf(n.oData.tab,e-1)})}),describe("Delete all tabs (function deleteTabByIndex)",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u));n.oData.tab.length;n._deleteTabByIndex(2),n._deleteTabByIndex(1),n._deleteTabByIndex(0),it("and return length of 0",function(){s.lengthOf(n.oData.tab,0)})}),describe("Function addTabWithName",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u));var e=n.oData.tab.length,t="newTab.js",r=n._getIndexTabByName(t);it("should add tab and length increment by "+(e+1),function(){if(-1!==r){var e=n.oData.tab.length;n._unactiveAllTab(),n._addTabWithName(t),s.lengthOf(n.oData.tab,e+1)}})}),describe("Function activeTabByIndex",function(){var n=new o["default"]("editor");n.setData(a.cloneDeep(u)),it("should return index 2",function(){n._unactiveAllTab(),n._activeTabByIndex(2),s.strictEqual(n._getIndexActiveTab(),2)})})})},function(n,e,t){n.exports=t(61)},function(n,e,t){/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=[],e=n.exports={};/*!
	 * Chai version
	 */
e.version="3.5.0",/*!
	 * Assertion Error
	 */
e.AssertionError=t(44);/*!
	 * Utils for plugins (not exported)
	 */
var i=t(75);e.use=function(n){return~r.indexOf(n)||(n(this,i),r.push(n)),this},/*!
	 * Utility Functions
	 */
e.util=i;/*!
	 * Configuration
	 */
var o=t(8);e.config=o;/*!
	 * Primary `Assertion` prototype
	 */
var s=t(62);e.use(s);/*!
	 * Core Assertions
	 */
var a=t(63);e.use(a);/*!
	 * Expect interface
	 */
var u=t(65);e.use(u);/*!
	 * Should interface
	 */
var l=t(66);e.use(l);/*!
	 * Assert interface
	 */
var f=t(64);e.use(f)},function(n,e,t){/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=t(8);n.exports=function(n,e){/*!
	   * Assertion Constructor
	   *
	   * Creates object for chaining.
	   *
	   * @api private
	   */
function t(n,e,t){o(this,"ssfi",t||arguments.callee),o(this,"object",n),o(this,"message",e)}/*!
	   * Module dependencies.
	   */
var i=n.AssertionError,o=e.flag;/*!
	   * Module export.
	   */
n.Assertion=t,Object.defineProperty(t,"includeStack",{get:function(){return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."),r.includeStack},set:function(n){console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."),r.includeStack=n}}),Object.defineProperty(t,"showDiff",{get:function(){return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."),r.showDiff},set:function(n){console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."),r.showDiff=n}}),t.addProperty=function(n,t){e.addProperty(this.prototype,n,t)},t.addMethod=function(n,t){e.addMethod(this.prototype,n,t)},t.addChainableMethod=function(n,t,r){e.addChainableMethod(this.prototype,n,t,r)},t.overwriteProperty=function(n,t){e.overwriteProperty(this.prototype,n,t)},t.overwriteMethod=function(n,t){e.overwriteMethod(this.prototype,n,t)},t.overwriteChainableMethod=function(n,t,r){e.overwriteChainableMethod(this.prototype,n,t,r)},t.prototype.assert=function(n,t,s,a,u,l){var f=e.test(this,arguments);if(!0!==l&&(l=!1),!0!==r.showDiff&&(l=!1),!f){var t=e.getMessage(this,arguments),c=e.getActual(this,arguments);throw new i(t,{actual:c,expected:a,showDiff:l},r.includeStack?this.assert:o(this,"ssfi"))}},/*!
	   * ### ._obj
	   *
	   * Quick reference to stored `actual` value for plugin developers.
	   *
	   * @api private
	   */
Object.defineProperty(t.prototype,"_obj",{get:function(){return o(this,"object")},set:function(n){o(this,"object",n)}})}},function(n,e){/*!
	 * chai
	 * http://chaijs.com
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e){function t(n,t){t&&R(this,"message",t),n=n.toLowerCase();var r=R(this,"object"),i=~["a","e","i","o","u"].indexOf(n.charAt(0))?"an ":"a ";this.assert(n===e.type(r),"expected #{this} to be "+i+n,"expected #{this} not to be "+i+n)}function r(){R(this,"contains",!0)}function i(n,t){e.expectTypes(this,["array","object","string"]),t&&R(this,"message",t);var r=R(this,"object"),i=!1;if("array"===e.type(r)&&"object"===e.type(n)){for(var o in r)if(e.eql(r[o],n)){i=!0;break}}else if("object"===e.type(n)){if(!R(this,"negate")){for(var s in n)new A(r).property(s,n[s]);return}var a={};for(var s in n)a[s]=r[s];i=e.eql(a,n)}else i=void 0!=r&&~r.indexOf(n);this.assert(i,"expected #{this} to include "+e.inspect(n),"expected #{this} to not include "+e.inspect(n))}function o(){var n=R(this,"object"),e=Object.prototype.toString.call(n);this.assert("[object Arguments]"===e,"expected #{this} to be arguments but got "+e,"expected #{this} to not be arguments")}function s(n,e){e&&R(this,"message",e);var t=R(this,"object");return R(this,"deep")?this.eql(n):void this.assert(n===t,"expected #{this} to equal #{exp}","expected #{this} to not equal #{exp}",n,this._obj,!0)}function a(n,t){t&&R(this,"message",t),this.assert(e.eql(n,R(this,"object")),"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",n,this._obj,!0)}function u(n,e){e&&R(this,"message",e);var t=R(this,"object");if(R(this,"doLength")){new A(t,e).to.have.property("length");var r=t.length;this.assert(r>n,"expected #{this} to have a length above #{exp} but got #{act}","expected #{this} to not have a length above #{exp}",n,r)}else this.assert(t>n,"expected #{this} to be above "+n,"expected #{this} to be at most "+n)}function l(n,e){e&&R(this,"message",e);var t=R(this,"object");if(R(this,"doLength")){new A(t,e).to.have.property("length");var r=t.length;this.assert(r>=n,"expected #{this} to have a length at least #{exp} but got #{act}","expected #{this} to have a length below #{exp}",n,r)}else this.assert(t>=n,"expected #{this} to be at least "+n,"expected #{this} to be below "+n)}function f(n,e){e&&R(this,"message",e);var t=R(this,"object");if(R(this,"doLength")){new A(t,e).to.have.property("length");var r=t.length;this.assert(n>r,"expected #{this} to have a length below #{exp} but got #{act}","expected #{this} to not have a length below #{exp}",n,r)}else this.assert(n>t,"expected #{this} to be below "+n,"expected #{this} to be at least "+n)}function c(n,e){e&&R(this,"message",e);var t=R(this,"object");if(R(this,"doLength")){new A(t,e).to.have.property("length");var r=t.length;this.assert(n>=r,"expected #{this} to have a length at most #{exp} but got #{act}","expected #{this} to have a length above #{exp}",n,r)}else this.assert(n>=t,"expected #{this} to be at most "+n,"expected #{this} to be above "+n)}function h(n,t){t&&R(this,"message",t);var r=e.getName(n);this.assert(R(this,"object")instanceof n,"expected #{this} to be an instance of "+r,"expected #{this} to not be an instance of "+r)}function p(n,t){t&&R(this,"message",t);var r=R(this,"object");this.assert(r.hasOwnProperty(n),"expected #{this} to have own property "+e.inspect(n),"expected #{this} to not have own property "+e.inspect(n))}function d(n,t,r){"string"==typeof t&&(r=t,t=null),r&&R(this,"message",r);var i=R(this,"object"),o=Object.getOwnPropertyDescriptor(Object(i),n);o&&t?this.assert(e.eql(t,o),"expected the own property descriptor for "+e.inspect(n)+" on #{this} to match "+e.inspect(t)+", got "+e.inspect(o),"expected the own property descriptor for "+e.inspect(n)+" on #{this} to not match "+e.inspect(t),t,o,!0):this.assert(o,"expected #{this} to have an own property descriptor for "+e.inspect(n),"expected #{this} to not have an own property descriptor for "+e.inspect(n)),R(this,"object",o)}function g(){R(this,"doLength",!0)}function m(n,e){e&&R(this,"message",e);var t=R(this,"object");new A(t,e).to.have.property("length");var r=t.length;this.assert(r==n,"expected #{this} to have a length of #{exp} but got #{act}","expected #{this} to not have a length of #{act}",n,r)}function b(n,e){e&&R(this,"message",e);var t=R(this,"object");this.assert(n.exec(t),"expected #{this} to match "+n,"expected #{this} not to match "+n)}function v(n){var t,r=R(this,"object"),i=!0,o="keys must be given single argument of Array|Object|String, or multiple String arguments";switch(e.type(n)){case"array":if(arguments.length>1)throw new Error(o);break;case"object":if(arguments.length>1)throw new Error(o);n=Object.keys(n);break;default:n=Array.prototype.slice.call(arguments)}if(!n.length)throw new Error("keys required");var s=Object.keys(r),a=n,u=n.length,l=R(this,"any"),f=R(this,"all");if(l||f||(f=!0),l){var c=a.filter(function(n){return~s.indexOf(n)});i=c.length>0}if(f&&(i=n.every(function(n){return~s.indexOf(n)}),R(this,"negate")||R(this,"contains")||(i=i&&n.length==s.length)),u>1){n=n.map(function(n){return e.inspect(n)});var h=n.pop();f&&(t=n.join(", ")+", and "+h),l&&(t=n.join(", ")+", or "+h)}else t=e.inspect(n[0]);t=(u>1?"keys ":"key ")+t,t=(R(this,"contains")?"contain ":"have ")+t,this.assert(i,"expected #{this} to "+t,"expected #{this} to not "+t,a.slice(0).sort(),s.sort(),!0)}function y(n,t,r){r&&R(this,"message",r);var i=R(this,"object");new A(i,r).is.a("function");var o=!1,s=null,a=null,u=null;0===arguments.length?(t=null,n=null):n&&(n instanceof RegExp||"string"==typeof n)?(t=n,n=null):n&&n instanceof Error?(s=n,n=null,t=null):"function"==typeof n?(a=n.prototype.name,(!a||"Error"===a&&n!==Error)&&(a=n.name||(new n).name)):n=null;try{i()}catch(l){if(s)return this.assert(l===s,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}",s instanceof Error?s.toString():s,l instanceof Error?l.toString():l),R(this,"object",l),this;if(n&&(this.assert(l instanceof n,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp} but #{act} was thrown",a,l instanceof Error?l.toString():l),!t))return R(this,"object",l),this;var f="error"===e.type(l)&&"message"in l?l.message:""+l;if(null!=f&&t&&t instanceof RegExp)return this.assert(t.exec(f),"expected #{this} to throw error matching #{exp} but got #{act}","expected #{this} to throw error not matching #{exp}",t,f),R(this,"object",l),this;if(null!=f&&t&&"string"==typeof t)return this.assert(~f.indexOf(t),"expected #{this} to throw error including #{exp} but got #{act}","expected #{this} to throw error not including #{act}",t,f),R(this,"object",l),this;o=!0,u=l}var c="",h=null!==a?a:s?"#{exp}":"an error";o&&(c=" but #{act} was thrown"),this.assert(o===!0,"expected #{this} to throw "+h+c,"expected #{this} to not throw "+h+c,s instanceof Error?s.toString():s,u instanceof Error?u.toString():u),R(this,"object",u)}function w(n,t){t&&R(this,"message",t);var r=R(this,"object"),i=R(this,"itself"),o="function"!==e.type(r)||i?r[n]:r.prototype[n];this.assert("function"==typeof o,"expected #{this} to respond to "+e.inspect(n),"expected #{this} to not respond to "+e.inspect(n))}function x(n,t){t&&R(this,"message",t);var r=R(this,"object"),i=n(r);this.assert(i,"expected #{this} to satisfy "+e.objDisplay(n),"expected #{this} to not satisfy"+e.objDisplay(n),this.negate?!1:!0,i)}function k(n,t,r){r&&R(this,"message",r);var i=R(this,"object");if(new A(i,r).is.a("number"),"number"!==e.type(n)||"number"!==e.type(t))throw new Error("the arguments to closeTo or approximately must be numbers");this.assert(Math.abs(i-n)<=t,"expected #{this} to be close to "+n+" +/- "+t,"expected #{this} not to be close to "+n+" +/- "+t)}function E(n,e,t){return n.every(function(n){return t?e.some(function(e){return t(n,e)}):-1!==e.indexOf(n)})}function _(n,e){e&&R(this,"message",e);var t=R(this,"object");new A(n).to.be.an("array"),this.assert(n.indexOf(t)>-1,"expected #{this} to be one of #{exp}","expected #{this} to not be one of #{exp}",n,t)}function S(n,e,t){t&&R(this,"message",t);var r=R(this,"object");new A(n,t).to.have.property(e),new A(r).is.a("function");var i=n[e];r(),this.assert(i!==n[e],"expected ."+e+" to change","expected ."+e+" to not change")}function T(n,e,t){t&&R(this,"message",t);var r=R(this,"object");new A(n,t).to.have.property(e),new A(r).is.a("function");var i=n[e];r(),this.assert(n[e]-i>0,"expected ."+e+" to increase","expected ."+e+" to not increase")}function O(n,e,t){t&&R(this,"message",t);var r=R(this,"object");new A(n,t).to.have.property(e),new A(r).is.a("function");var i=n[e];r(),this.assert(n[e]-i<0,"expected ."+e+" to decrease","expected ."+e+" to not decrease")}var A=n.Assertion,R=(Object.prototype.toString,e.flag);["to","be","been","is","and","has","have","with","that","which","at","of","same"].forEach(function(n){A.addProperty(n,function(){return this})}),A.addProperty("not",function(){R(this,"negate",!0)}),A.addProperty("deep",function(){R(this,"deep",!0)}),A.addProperty("any",function(){R(this,"any",!0),R(this,"all",!1)}),A.addProperty("all",function(){R(this,"all",!0),R(this,"any",!1)}),A.addChainableMethod("an",t),A.addChainableMethod("a",t),A.addChainableMethod("include",i,r),A.addChainableMethod("contain",i,r),A.addChainableMethod("contains",i,r),A.addChainableMethod("includes",i,r),A.addProperty("ok",function(){this.assert(R(this,"object"),"expected #{this} to be truthy","expected #{this} to be falsy")}),A.addProperty("true",function(){this.assert(!0===R(this,"object"),"expected #{this} to be true","expected #{this} to be false",this.negate?!1:!0)}),A.addProperty("false",function(){this.assert(!1===R(this,"object"),"expected #{this} to be false","expected #{this} to be true",this.negate?!0:!1)}),A.addProperty("null",function(){this.assert(null===R(this,"object"),"expected #{this} to be null","expected #{this} not to be null")}),A.addProperty("undefined",function(){this.assert(void 0===R(this,"object"),"expected #{this} to be undefined","expected #{this} not to be undefined")}),A.addProperty("NaN",function(){this.assert(isNaN(R(this,"object")),"expected #{this} to be NaN","expected #{this} not to be NaN")}),A.addProperty("exist",function(){this.assert(null!=R(this,"object"),"expected #{this} to exist","expected #{this} to not exist")}),A.addProperty("empty",function(){var n=R(this,"object"),e=n;Array.isArray(n)||"string"==typeof object?e=n.length:"object"==typeof n&&(e=Object.keys(n).length),this.assert(!e,"expected #{this} to be empty","expected #{this} not to be empty")}),A.addProperty("arguments",o),A.addProperty("Arguments",o),A.addMethod("equal",s),A.addMethod("equals",s),A.addMethod("eq",s),A.addMethod("eql",a),A.addMethod("eqls",a),A.addMethod("above",u),A.addMethod("gt",u),A.addMethod("greaterThan",u),A.addMethod("least",l),A.addMethod("gte",l),A.addMethod("below",f),A.addMethod("lt",f),A.addMethod("lessThan",f),A.addMethod("most",c),A.addMethod("lte",c),A.addMethod("within",function(n,e,t){t&&R(this,"message",t);var r=R(this,"object"),i=n+".."+e;if(R(this,"doLength")){new A(r,t).to.have.property("length");var o=r.length;this.assert(o>=n&&e>=o,"expected #{this} to have a length within "+i,"expected #{this} to not have a length within "+i)}else this.assert(r>=n&&e>=r,"expected #{this} to be within "+i,"expected #{this} to not be within "+i)}),A.addMethod("instanceof",h),A.addMethod("instanceOf",h),A.addMethod("property",function(n,t,r){r&&R(this,"message",r);var i=!!R(this,"deep"),o=i?"deep property ":"property ",s=R(this,"negate"),a=R(this,"object"),u=i?e.getPathInfo(n,a):null,l=i?u.exists:e.hasProperty(n,a),f=i?u.value:a[n];if(s&&arguments.length>1){if(void 0===f)throw r=null!=r?r+": ":"",new Error(r+e.inspect(a)+" has no "+o+e.inspect(n))}else this.assert(l,"expected #{this} to have a "+o+e.inspect(n),"expected #{this} to not have "+o+e.inspect(n));arguments.length>1&&this.assert(t===f,"expected #{this} to have a "+o+e.inspect(n)+" of #{exp}, but got #{act}","expected #{this} to not have a "+o+e.inspect(n)+" of #{act}",t,f),R(this,"object",f)}),A.addMethod("ownProperty",p),A.addMethod("haveOwnProperty",p),A.addMethod("ownPropertyDescriptor",d),A.addMethod("haveOwnPropertyDescriptor",d),A.addChainableMethod("length",m,g),A.addMethod("lengthOf",m),A.addMethod("match",b),A.addMethod("matches",b),A.addMethod("string",function(n,t){t&&R(this,"message",t);var r=R(this,"object");new A(r,t).is.a("string"),this.assert(~r.indexOf(n),"expected #{this} to contain "+e.inspect(n),"expected #{this} to not contain "+e.inspect(n))}),A.addMethod("keys",v),A.addMethod("key",v),A.addMethod("throw",y),A.addMethod("throws",y),A.addMethod("Throw",y),A.addMethod("respondTo",w),A.addMethod("respondsTo",w),A.addProperty("itself",function(){R(this,"itself",!0)}),A.addMethod("satisfy",x),A.addMethod("satisfies",x),A.addMethod("closeTo",k),A.addMethod("approximately",k),A.addMethod("members",function(n,t){t&&R(this,"message",t);var r=R(this,"object");new A(r).to.be.an("array"),new A(n).to.be.an("array");var i=R(this,"deep")?e.eql:void 0;return R(this,"contains")?this.assert(E(n,r,i),"expected #{this} to be a superset of #{act}","expected #{this} to not be a superset of #{act}",r,n):void this.assert(E(r,n,i)&&E(n,r,i),"expected #{this} to have the same members as #{act}","expected #{this} to not have the same members as #{act}",r,n)}),A.addMethod("oneOf",_),A.addChainableMethod("change",S),A.addChainableMethod("changes",S),A.addChainableMethod("increase",T),A.addChainableMethod("increases",T),A.addChainableMethod("decrease",O),A.addChainableMethod("decreases",O),A.addProperty("extensible",function(){var n,e=R(this,"object");try{n=Object.isExtensible(e)}catch(t){if(!(t instanceof TypeError))throw t;n=!1}this.assert(n,"expected #{this} to be extensible","expected #{this} to not be extensible")}),A.addProperty("sealed",function(){var n,e=R(this,"object");try{n=Object.isSealed(e)}catch(t){if(!(t instanceof TypeError))throw t;n=!0}this.assert(n,"expected #{this} to be sealed","expected #{this} to not be sealed")}),A.addProperty("frozen",function(){var n,e=R(this,"object");try{n=Object.isFrozen(e)}catch(t){if(!(t instanceof TypeError))throw t;n=!0}this.assert(n,"expected #{this} to be frozen","expected #{this} to not be frozen")})}},function(n,e){/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e){/*!
	   * Chai dependencies.
	   */
var t=n.Assertion,r=e.flag,i=n.assert=function(e,r){var i=new t(null,null,n.assert);i.assert(e,r,"[ negation message unavailable ]")};i.fail=function(e,t,r,o){throw r=r||"assert.fail()",new n.AssertionError(r,{actual:e,expected:t,operator:o},i.fail)},i.isOk=function(n,e){new t(n,e).is.ok},i.isNotOk=function(n,e){new t(n,e).is.not.ok},i.equal=function(n,e,o){var s=new t(n,o,i.equal);s.assert(e==r(s,"object"),"expected #{this} to equal #{exp}","expected #{this} to not equal #{act}",e,n)},i.notEqual=function(n,e,o){var s=new t(n,o,i.notEqual);s.assert(e!=r(s,"object"),"expected #{this} to not equal #{exp}","expected #{this} to equal #{act}",e,n)},i.strictEqual=function(n,e,r){new t(n,r).to.equal(e)},i.notStrictEqual=function(n,e,r){new t(n,r).to.not.equal(e)},i.deepEqual=function(n,e,r){new t(n,r).to.eql(e)},i.notDeepEqual=function(n,e,r){new t(n,r).to.not.eql(e)},i.isAbove=function(n,e,r){new t(n,r).to.be.above(e)},i.isAtLeast=function(n,e,r){new t(n,r).to.be.least(e)},i.isBelow=function(n,e,r){new t(n,r).to.be.below(e)},i.isAtMost=function(n,e,r){new t(n,r).to.be.most(e)},i.isTrue=function(n,e){new t(n,e).is["true"]},i.isNotTrue=function(n,e){new t(n,e).to.not.equal(!0)},i.isFalse=function(n,e){new t(n,e).is["false"]},i.isNotFalse=function(n,e){new t(n,e).to.not.equal(!1)},i.isNull=function(n,e){new t(n,e).to.equal(null)},i.isNotNull=function(n,e){new t(n,e).to.not.equal(null)},i.isNaN=function(n,e){new t(n,e).to.be.NaN},i.isNotNaN=function(n,e){new t(n,e).not.to.be.NaN},i.isUndefined=function(n,e){new t(n,e).to.equal(void 0)},i.isDefined=function(n,e){new t(n,e).to.not.equal(void 0)},i.isFunction=function(n,e){new t(n,e).to.be.a("function")},i.isNotFunction=function(n,e){new t(n,e).to.not.be.a("function")},i.isObject=function(n,e){new t(n,e).to.be.a("object")},i.isNotObject=function(n,e){new t(n,e).to.not.be.a("object")},i.isArray=function(n,e){new t(n,e).to.be.an("array")},i.isNotArray=function(n,e){new t(n,e).to.not.be.an("array")},i.isString=function(n,e){new t(n,e).to.be.a("string")},i.isNotString=function(n,e){new t(n,e).to.not.be.a("string")},i.isNumber=function(n,e){new t(n,e).to.be.a("number")},i.isNotNumber=function(n,e){new t(n,e).to.not.be.a("number")},i.isBoolean=function(n,e){new t(n,e).to.be.a("boolean")},i.isNotBoolean=function(n,e){new t(n,e).to.not.be.a("boolean")},i.typeOf=function(n,e,r){new t(n,r).to.be.a(e)},i.notTypeOf=function(n,e,r){new t(n,r).to.not.be.a(e)},i.instanceOf=function(n,e,r){new t(n,r).to.be.instanceOf(e)},i.notInstanceOf=function(n,e,r){new t(n,r).to.not.be.instanceOf(e)},i.include=function(n,e,r){new t(n,r,i.include).include(e)},i.notInclude=function(n,e,r){new t(n,r,i.notInclude).not.include(e)},i.match=function(n,e,r){new t(n,r).to.match(e)},i.notMatch=function(n,e,r){new t(n,r).to.not.match(e)},i.property=function(n,e,r){new t(n,r).to.have.property(e)},i.notProperty=function(n,e,r){new t(n,r).to.not.have.property(e)},i.deepProperty=function(n,e,r){new t(n,r).to.have.deep.property(e)},i.notDeepProperty=function(n,e,r){new t(n,r).to.not.have.deep.property(e)},i.propertyVal=function(n,e,r,i){new t(n,i).to.have.property(e,r)},i.propertyNotVal=function(n,e,r,i){new t(n,i).to.not.have.property(e,r)},i.deepPropertyVal=function(n,e,r,i){new t(n,i).to.have.deep.property(e,r)},i.deepPropertyNotVal=function(n,e,r,i){new t(n,i).to.not.have.deep.property(e,r)},i.lengthOf=function(n,e,r){new t(n,r).to.have.length(e)},i["throws"]=function(n,e,i,o){("string"==typeof e||e instanceof RegExp)&&(i=e,e=null);var s=new t(n,o).to["throw"](e,i);return r(s,"object")},i.doesNotThrow=function(n,e,r){"string"==typeof e&&(r=e,e=null),new t(n,r).to.not.Throw(e)},i.operator=function(n,i,o,s){var a;switch(i){case"==":a=n==o;break;case"===":a=n===o;break;case">":a=n>o;break;case">=":a=n>=o;break;case"<":a=o>n;break;case"<=":a=o>=n;break;case"!=":a=n!=o;break;case"!==":a=n!==o;break;default:throw new Error('Invalid operator "'+i+'"')}var u=new t(a,s);u.assert(!0===r(u,"object"),"expected "+e.inspect(n)+" to be "+i+" "+e.inspect(o),"expected "+e.inspect(n)+" to not be "+i+" "+e.inspect(o))},i.closeTo=function(n,e,r,i){new t(n,i).to.be.closeTo(e,r)},i.approximately=function(n,e,r,i){new t(n,i).to.be.approximately(e,r)},i.sameMembers=function(n,e,r){new t(n,r).to.have.same.members(e)},i.sameDeepMembers=function(n,e,r){new t(n,r).to.have.same.deep.members(e)},i.includeMembers=function(n,e,r){new t(n,r).to.include.members(e)},i.includeDeepMembers=function(n,e,r){new t(n,r).to.include.deep.members(e)},i.oneOf=function(n,e,r){new t(n,r).to.be.oneOf(e)},i.changes=function(n,e,r){new t(n).to.change(e,r)},i.doesNotChange=function(n,e,r){new t(n).to.not.change(e,r)},i.increases=function(n,e,r){new t(n).to.increase(e,r)},i.doesNotIncrease=function(n,e,r){new t(n).to.not.increase(e,r)},i.decreases=function(n,e,r){new t(n).to.decrease(e,r)},i.doesNotDecrease=function(n,e,r){new t(n).to.not.decrease(e,r)},/*!
	   * ### .ifError(object)
	   *
	   * Asserts if value is not a false value, and throws if it is a true value.
	   * This is added to allow for chai to be a drop-in replacement for Node's
	   * assert class.
	   *
	   *     var err = new Error('I am a custom error');
	   *     assert.ifError(err); // Rethrows err!
	   *
	   * @name ifError
	   * @param {Object} object
	   * @namespace Assert
	   * @api public
	   */
i.ifError=function(n){if(n)throw n},i.isExtensible=function(n,e){new t(n,e).to.be.extensible},i.isNotExtensible=function(n,e){new t(n,e).to.not.be.extensible},i.isSealed=function(n,e){new t(n,e).to.be.sealed},i.isNotSealed=function(n,e){new t(n,e).to.not.be.sealed},i.isFrozen=function(n,e){new t(n,e).to.be.frozen},i.isNotFrozen=function(n,e){new t(n,e).to.not.be.frozen},/*!
	   * Aliases.
	   */
function o(n,e){return i[e]=i[n],o}("isOk","ok")("isNotOk","notOk")("throws","throw")("throws","Throw")("isExtensible","extensible")("isNotExtensible","notExtensible")("isSealed","sealed")("isNotSealed","notSealed")("isFrozen","frozen")("isNotFrozen","notFrozen")}},function(n,e){/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e){n.expect=function(e,t){return new n.Assertion(e,t)},n.expect.fail=function(e,t,r,i){throw r=r||"expect.fail()",new n.AssertionError(r,{actual:e,expected:t,operator:i},n.expect.fail)}}},function(n,e){/*!
	 * chai
	 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e){function t(){function e(){return this instanceof String||this instanceof Number||this instanceof Boolean?new r(this.valueOf(),null,e):new r(this,null,e)}function t(n){Object.defineProperty(this,"should",{value:n,enumerable:!0,configurable:!0,writable:!0})}Object.defineProperty(Object.prototype,"should",{set:t,get:e,configurable:!0});var i={};return i.fail=function(e,t,r,o){throw r=r||"should.fail()",new n.AssertionError(r,{actual:e,expected:t,operator:o},i.fail)},i.equal=function(n,e,t){new r(n,t).to.equal(e)},i.Throw=function(n,e,t,i){new r(n,i).to.Throw(e,t)},i.exist=function(n,e){new r(n,e).to.exist},i.not={},i.not.equal=function(n,e,t){new r(n,t).to.not.equal(e)},i.not.Throw=function(n,e,t,i){new r(n,i).to.not.Throw(e,t)},i.not.exist=function(n,e){new r(n,e).to.not.exist},i["throw"]=i.Throw,i.not["throw"]=i.not.Throw,i}var r=n.Assertion;n.should=t,n.Should=t}},function(n,e,t){/*!
	 * Chai - addChainingMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Module dependencies
	 */
var r=t(43),i=t(4),o=t(8),s="__proto__"in Object,a=/^(?:length|name|arguments|caller)$/,u=Function.prototype.call,l=Function.prototype.apply;n.exports=function(n,e,t,f){"function"!=typeof f&&(f=function(){});var c={method:t,chainingBehavior:f};n.__methods||(n.__methods={}),n.__methods[e]=c,Object.defineProperty(n,e,{get:function(){c.chainingBehavior.call(this);var e=function h(){var n=i(this,"ssfi");n&&o.includeStack===!1&&i(this,"ssfi",h);var e=c.method.apply(this,arguments);return void 0===e?this:e};if(s){var t=e.__proto__=Object.create(this);t.call=u,t.apply=l}else{var f=Object.getOwnPropertyNames(n);f.forEach(function(t){if(!a.test(t)){var r=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,r)}})}return r(this,e),e},configurable:!0})}},function(n,e,t){/*!
	 * Chai - addMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=t(8),i=t(4);n.exports=function(n,e,t){n[e]=function(){var o=i(this,"ssfi");o&&r.includeStack===!1&&i(this,"ssfi",n[e]);var s=t.apply(this,arguments);return void 0===s?this:s}}},function(n,e,t){/*!
	 * Chai - addProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=t(8),i=t(4);n.exports=function(n,e,t){Object.defineProperty(n,e,{get:function o(){var n=i(this,"ssfi");n&&r.includeStack===!1&&i(this,"ssfi",o);var e=t.call(this);return void 0===e?this:e},configurable:!0})}},function(n,e,t){/*!
	 * Chai - expectTypes utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
var r=t(44),i=t(4),o=t(20);n.exports=function(n,e){var n=i(n,"object");e=e.map(function(n){return n.toLowerCase()}),e.sort();var t=e.map(function(n,t){var r=~["a","e","i","o","u"].indexOf(n.charAt(0))?"an":"a",i=e.length>1&&t===e.length-1?"or ":"";return i+r+" "+n}).join(", ");if(!e.some(function(e){return o(n)===e}))throw new r("object tested must be "+t+", but "+o(n)+" given")}},function(n,e){/*!
	 * Chai - getEnumerableProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n){var e=[];for(var t in n)e.push(t);return e}},function(n,e,t){/*!
	 * Chai - message composition utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Module dependancies
	 */
var r=t(4),i=t(38),o=(t(19),t(42));n.exports=function(n,e){var t=r(n,"negate"),s=r(n,"object"),a=e[3],u=i(n,e),l=t?e[2]:e[1],f=r(n,"message");return"function"==typeof l&&(l=l()),l=l||"",l=l.replace(/#\{this\}/g,function(){return o(s)}).replace(/#\{act\}/g,function(){return o(u)}).replace(/#\{exp\}/g,function(){return o(a)}),f?f+": "+l:l}},function(n,e,t){/*!
	 * Chai - getPathValue utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * @see https://github.com/logicalparadox/filtr
	 * MIT Licensed
	 */
var r=t(40);n.exports=function(n,e){var t=r(n,e);return t.value}},function(n,e){/*!
	 * Chai - getProperties utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n){function e(n){-1===t.indexOf(n)&&t.push(n)}for(var t=Object.getOwnPropertyNames(n),r=Object.getPrototypeOf(n);null!==r;)Object.getOwnPropertyNames(r).forEach(e),r=Object.getPrototypeOf(r);return t}},function(n,e,t){/*!
	 * chai
	 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Main exports
	 */
var e=n.exports={};/*!
	 * test utility
	 */
e.test=t(79),/*!
	 * type utility
	 */
e.type=t(20),/*!
	 * expectTypes utility
	 */
e.expectTypes=t(70),/*!
	 * message utility
	 */
e.getMessage=t(72),/*!
	 * actual utility
	 */
e.getActual=t(38),/*!
	 * Inspect util
	 */
e.inspect=t(19),/*!
	 * Object Display util
	 */
e.objDisplay=t(42),/*!
	 * Flag utility
	 */
e.flag=t(4),/*!
	 * Flag transferring utility
	 */
e.transferFlags=t(43),/*!
	 * Deep equal utility
	 */
e.eql=t(80),/*!
	 * Deep path value
	 */
e.getPathValue=t(73),/*!
	 * Deep path info
	 */
e.getPathInfo=t(40),/*!
	 * Check if a property exists
	 */
e.hasProperty=t(41),/*!
	 * Function name
	 */
e.getName=t(39),/*!
	 * add Property
	 */
e.addProperty=t(69),/*!
	 * add Method
	 */
e.addMethod=t(68),/*!
	 * overwrite Property
	 */
e.overwriteProperty=t(78),/*!
	 * overwrite Method
	 */
e.overwriteMethod=t(77),/*!
	 * Add a chainable method
	 */
e.addChainableMethod=t(67),/*!
	 * Overwrite chainable method
	 */
e.overwriteChainableMethod=t(76)},function(n,e){/*!
	 * Chai - overwriteChainableMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e,t,r){var i=n.__methods[e],o=i.chainingBehavior;i.chainingBehavior=function(){var n=r(o).call(this);return void 0===n?this:n};var s=i.method;i.method=function(){var n=t(s).apply(this,arguments);return void 0===n?this:n}}},function(n,e){/*!
	 * Chai - overwriteMethod utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e,t){var r=n[e],i=function(){return this};r&&"function"==typeof r&&(i=r),n[e]=function(){var n=t(i).apply(this,arguments);return void 0===n?this:n}}},function(n,e){/*!
	 * Chai - overwriteProperty utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
n.exports=function(n,e,t){var r=Object.getOwnPropertyDescriptor(n,e),i=function(){};r&&"function"==typeof r.get&&(i=r.get),Object.defineProperty(n,e,{get:function(){var n=t(i).call(this);return void 0===n?this:n},configurable:!0})}},function(n,e,t){/*!
	 * Chai - test utility
	 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Module dependancies
	 */
var r=t(4);n.exports=function(n,e){var t=r(n,"negate"),i=e[0];return t?!i:i}},function(n,e,t){n.exports=t(81)},function(n,e,t){function r(n,e,t){return i(n,e)?!0:"date"===g(n)?s(n,e):"regexp"===g(n)?a(n,e):d.isBuffer(n)?c(n,e):"arguments"===g(n)?u(n,e,t):o(n,e)?"object"!==g(n)&&"object"!==g(e)&&"array"!==g(n)&&"array"!==g(e)?i(n,e):p(n,e,t):!1}/*!
	 * Strict (egal) equality test. Ensures that NaN always
	 * equals NaN and `-0` does not equal `+0`.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} equal match
	 */
function i(n,e){return n===e?0!==n||1/n===1/e:n!==n&&e!==e}/*!
	 * Compare the types of two given objects and
	 * return if they are equal. Note that an Array
	 * has a type of `array` (not `object`) and arguments
	 * have a type of `arguments` (not `array`/`object`).
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
function o(n,e){return g(n)===g(e)}/*!
	 * Compare two Date objects by asserting that
	 * the time values are equal using `saveValue`.
	 *
	 * @param {Date} a
	 * @param {Date} b
	 * @return {Boolean} result
	 */
function s(n,e){return"date"!==g(e)?!1:i(n.getTime(),e.getTime())}/*!
	 * Compare two regular expressions by converting them
	 * to string and checking for `sameValue`.
	 *
	 * @param {RegExp} a
	 * @param {RegExp} b
	 * @return {Boolean} result
	 */
function a(n,e){return"regexp"!==g(e)?!1:i(n.toString(),e.toString())}/*!
	 * Assert deep equality of two `arguments` objects.
	 * Unfortunately, these must be sliced to arrays
	 * prior to test to ensure no bad behavior.
	 *
	 * @param {Arguments} a
	 * @param {Arguments} b
	 * @param {Array} memoize (optional)
	 * @return {Boolean} result
	 */
function u(n,e,t){return"arguments"!==g(e)?!1:(n=[].slice.call(n),e=[].slice.call(e),r(n,e,t))}/*!
	 * Get enumerable properties of a given object.
	 *
	 * @param {Object} a
	 * @return {Array} property names
	 */
function l(n){var e=[];for(var t in n)e.push(t);return e}/*!
	 * Simple equality for flat iterable objects
	 * such as Arrays or Node.js buffers.
	 *
	 * @param {Iterable} a
	 * @param {Iterable} b
	 * @return {Boolean} result
	 */
function f(n,e){if(n.length!==e.length)return!1;for(var t=0,r=!0;t<n.length;t++)if(n[t]!==e[t]){r=!1;break}return r}/*!
	 * Extension to `iterableEqual` specifically
	 * for Node.js Buffers.
	 *
	 * @param {Buffer} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
function c(n,e){return d.isBuffer(e)?f(n,e):!1}/*!
	 * Block for `objectEqual` ensuring non-existing
	 * values don't get in.
	 *
	 * @param {Mixed} object
	 * @return {Boolean} result
	 */
function h(n){return null!==n&&void 0!==n}/*!
	 * Recursively check the equality of two objects.
	 * Once basic sameness has been established it will
	 * defer to `deepEqual` for each enumerable key
	 * in the object.
	 *
	 * @param {Mixed} a
	 * @param {Mixed} b
	 * @return {Boolean} result
	 */
function p(n,e,t){if(!h(n)||!h(e))return!1;if(n.prototype!==e.prototype)return!1;var i;if(t){for(i=0;i<t.length;i++)if(t[i][0]===n&&t[i][1]===e||t[i][0]===e&&t[i][1]===n)return!0}else t=[];try{var o=l(n),s=l(e)}catch(a){return!1}if(o.sort(),s.sort(),!f(o,s))return!1;t.push([n,e]);var u;for(i=o.length-1;i>=0;i--)if(u=o[i],!r(n[u],e[u],t))return!1;return!0}/*!
	 * deep-eql
	 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Module dependencies
	 */
var d,g=t(82);try{d=t(45).Buffer}catch(m){d={},d.isBuffer=function(){return!1}}/*!
	 * Primary Export
	 */
n.exports=r},function(n,e,t){n.exports=t(83)},function(n,e){function t(n){var e=Object.prototype.toString.call(n);return i[e]?i[e]:null===n?"null":void 0===n?"undefined":n===Object(n)?"object":typeof n}function r(){this.tests={}}/*!
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Primary Exports
	 */
var e=n.exports=t,i={"[object Array]":"array","[object RegExp]":"regexp","[object Function]":"function","[object Arguments]":"arguments","[object Date]":"date"};e.Library=r,r.prototype.of=t,r.prototype.define=function(n,e){return 1===arguments.length?this.tests[n]:(this.tests[n]=e,this)},r.prototype.test=function(n,e){if(e===t(n))return!0;var r=this.tests[e];if(r&&"regexp"===t(r))return r.test(n);if(r&&"function"===t(r))return r(n);throw new ReferenceError('Type test "'+e+'" not defined or invalid.')}},function(n,e){function t(n){var e=Object.prototype.toString.call(n).match(i)[1].toLowerCase();return"function"==typeof Promise&&n instanceof Promise?"promise":null===n?"null":void 0===n?"undefined":e}function r(){return this instanceof r?void(this.tests={}):new r}/*!
	 * type-detect
	 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
	 * MIT Licensed
	 */
/*!
	 * Primary Exports
	 */
var e=n.exports=t,i=/^\[object (.*)\]$/;e.Library=r,r.prototype.of=t,r.prototype.define=function(n,e){return 1===arguments.length?this.tests[n]:(this.tests[n]=e,this)},r.prototype.test=function(n,e){if(e===t(n))return!0;var r=this.tests[e];if(r&&"regexp"===t(r))return r.test(n);if(r&&"function"===t(r))return r(n);throw new ReferenceError('Type test "'+e+'" not defined or invalid.')}},,function(n,e){n.exports=function(){var n=[];return n.toString=function(){for(var n=[],e=0;e<this.length;e++){var t=this[e];t[2]?n.push("@media "+t[2]+"{"+t[1]+"}"):n.push(t[1])}return n.join("")},n}},function(n,e,t){e=n.exports=t(86)(),e.push([n.id,"@charset \"utf-8\";body{margin:0}#mocha{font:20px/1.5 \"Helvetica Neue\",Helvetica,Arial,sans-serif;margin:60px 50px}#mocha ul,#mocha li{margin:0;padding:0}#mocha ul{list-style:none}#mocha h2{margin:0}#mocha h1{margin:15px 0 0;font-size:1em;font-weight:200}#mocha h1 a{text-decoration:none;color:inherit}#mocha h1 a:hover{text-decoration:underline}#mocha .suite .suite h1{margin-top:0;font-size:.8em}#mocha .hidden{display:none}#mocha h2{font-size:12px;font-weight:400;cursor:pointer}#mocha .suite,#mocha .test{margin-left:15px}#mocha .test{overflow:hidden}#mocha .test.pending:hover h2::after{content:'(pending)';font-family:arial,sans-serif}#mocha .test.pass.medium .duration{background:#c09853}#mocha .test.pass.slow .duration{background:#b94a48}#mocha .test.pass::before{content:'';font-size:12px;display:block;float:left;margin-right:5px;color:#00d6b2}#mocha .test.pass .duration{font-size:9px;margin-left:5px;padding:2px 5px;color:#fff;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.2);-moz-box-shadow:inset 0 1px 1px rgba(0,0,0,.2);box-shadow:inset 0 1px 1px rgba(0,0,0,.2);-webkit-border-radius:5px;-moz-border-radius:5px;-ms-border-radius:5px;-o-border-radius:5px;border-radius:5px}#mocha .test.pass.fast .duration{display:none}#mocha .test.pending{color:#0b97c4}#mocha .test.pending::before{content:'';color:#0b97c4}#mocha .test.fail{color:#c00}#mocha .test.fail pre{color:#000}#mocha .test.fail::before{content:'';font-size:12px;display:block;float:left;margin-right:5px;color:#c00}#mocha .test pre.error{color:#c00;max-height:300px;overflow:auto}#mocha .test .html-error{overflow:auto;color:#000;line-height:1.5;display:block;float:left;clear:left;font:12px/1.5 monaco,monospace;margin:5px;padding:15px;border:1px solid #eee;max-width:calc(100% - 42px);max-height:300px;word-wrap:break-word;border-bottom-color:#ddd;-webkit-border-radius:3px;-webkit-box-shadow:0 1px 3px #eee;-moz-border-radius:3px;-moz-box-shadow:0 1px 3px #eee;border-radius:3px}#mocha .test .html-error pre.error{border:none;-webkit-border-radius:none;-webkit-box-shadow:none;-moz-border-radius:none;-moz-box-shadow:none;padding:0;margin:18px 0 0;max-height:none}#mocha .test pre{display:block;float:left;clear:left;font:12px/1.5 monaco,monospace;margin:5px;padding:15px;border:1px solid #eee;max-width:calc(100% - 42px);word-wrap:break-word;border-bottom-color:#ddd;-webkit-border-radius:3px;-webkit-box-shadow:0 1px 3px #eee;-moz-border-radius:3px;-moz-box-shadow:0 1px 3px #eee;border-radius:3px}#mocha .test h2{position:relative}#mocha .test a.replay{position:absolute;top:3px;right:0;text-decoration:none;vertical-align:middle;display:block;width:15px;height:15px;line-height:15px;text-align:center;background:#eee;font-size:15px;-moz-border-radius:15px;border-radius:15px;-webkit-transition:opacity 200ms;-moz-transition:opacity 200ms;transition:opacity 200ms;opacity:.3;color:#888}#mocha .test:hover a.replay{opacity:1}#mocha-report.pass .test.fail,#mocha-report.fail .test.pass,#mocha-report.pending .test.pass,#mocha-report.pending .test.fail{display:none}#mocha-report.pending .test.pass.pending{display:block}#mocha-error{color:#c00;font-size:1.5em;font-weight:100;letter-spacing:1px}#mocha-stats{position:fixed;top:15px;right:10px;font-size:12px;margin:0;color:#888;z-index:1}#mocha-stats .progress{float:right;padding-top:0}#mocha-stats em{color:#000}#mocha-stats a{text-decoration:none;color:inherit}#mocha-stats a:hover{border-bottom:1px solid #eee}#mocha-stats li{display:inline-block;margin:0 5px;list-style:none;padding-top:11px}#mocha-stats canvas{width:40px;height:40px}#mocha code .comment{color:#ddd}#mocha code .init{color:#2f6fad}#mocha code .string{color:#5890ad}#mocha code .keyword{color:#8a6343}#mocha code .number{color:#2f6fad}@media screen and (max-device-width:480px){#mocha{margin:60px 0}#mocha #stats{position:absolute}}",""])},function(n,e){n.exports=function(n){"function"==typeof execScript?execScript(n):eval.call(null,n)}},function(n,e,t){t(88)(t(94))},function(n,e,t){function r(n,e){for(var t=0;t<n.length;t++){var r=n[t],i=f[r.id];if(i){i.refs++;for(var o=0;o<i.parts.length;o++)i.parts[o](r.parts[o]);for(;o<r.parts.length;o++)i.parts.push(s(r.parts[o],e))}else{for(var a=[],o=0;o<r.parts.length;o++)a.push(s(r.parts[o],e));f[r.id]={id:r.id,refs:1,parts:a}}}}function i(n){for(var e=[],t={},r=0;r<n.length;r++){var i=n[r],o=i[0],s=i[1],a=i[2],u=i[3],l={css:s,media:a,sourceMap:u};t[o]?t[o].parts.push(l):e.push(t[o]={id:o,parts:[l]})}return e}function o(){var n=document.createElement("style"),e=p();return n.type="text/css",e.appendChild(n),n}function s(n,e){var t,r,i;if(e.singleton){var s=g++;t=d||(d=o()),r=u.bind(null,t,s,!1),i=u.bind(null,t,s,!0)}else t=o(),r=l.bind(null,t),i=function(){t.parentNode.removeChild(t)};return r(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;r(n=e)}else i()}}function a(n,e,t){var r=["/** >>"+e+" **/","/** "+e+"<< **/"],i=n.lastIndexOf(r[0]),o=t?r[0]+t+r[1]:"";if(n.lastIndexOf(r[0])>=0){var s=n.lastIndexOf(r[1])+r[1].length;return n.slice(0,i)+o+n.slice(s)}return n+o}function u(n,e,t,r){var i=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=a(n.styleSheet.cssText,e,i);else{var o=document.createTextNode(i),s=n.childNodes;s[e]&&n.removeChild(s[e]),s.length?n.insertBefore(o,s[e]):n.appendChild(o)}}function l(n,e){var t=e.css,r=e.media,i=e.sourceMap;if(i&&"function"==typeof btoa)try{t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(JSON.stringify(i))+" */",t='@import url("data:text/css;base64,'+btoa(t)+'")'}catch(o){}if(r&&n.setAttribute("media",r),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}var f={},c=function(n){var e;return function(){return"undefined"==typeof e&&(e=n.apply(this,arguments)),e}},h=c(function(){return/msie 9\b/.test(window.navigator.userAgent.toLowerCase())}),p=c(function(){return document.head||document.getElementsByTagName("head")[0]}),d=null,g=0;n.exports=function(n,e){e=e||{},"undefined"==typeof e.singleton&&(e.singleton=h());var t=i(n);return r(t,e),function(n){for(var o=[],s=0;s<t.length;s++){var a=t[s],u=f[a.id];u.refs--,o.push(u)}if(n){var l=i(n);r(l,e)}for(var s=0;s<o.length;s++){var u=o[s];if(0===u.refs){for(var c=0;c<u.parts.length;c++)u.parts[c]();delete f[u.id]}}}}},function(n,e,t){var r=t(87);"string"==typeof r&&(r=[[n.id,r,""]]);t(90)(r,{})},function(n,e,t){(function(e){e.nextTick(function(){delete t.c[n.id],"undefined"!=typeof window&&window.mochaPhantomJS?mochaPhantomJS.run():mocha.run()})}).call(e,t(98))},function(n,e,t){document.getElementById("mocha")||document.write('<div id="mocha"></div>'),t(91),t(89)},function(n,e){n.exports="(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\nmodule.exports = process.env.COV\n  ? require('./lib-cov/mocha')\n  : require('./lib/mocha');\n\n}).call(this,require('_process'))\n},{\"./lib-cov/mocha\":undefined,\"./lib/mocha\":14,\"_process\":51}],2:[function(require,module,exports){\n/* eslint-disable no-unused-vars */\nmodule.exports = function(type) {\n  return function() {};\n};\n\n},{}],3:[function(require,module,exports){\n/**\n * Module exports.\n */\n\nexports.EventEmitter = EventEmitter;\n\n/**\n * Object#hasOwnProperty reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check if a value is an array.\n *\n * @api private\n * @param {*} val The value to test.\n * @return {boolean} true if the value is a boolean, otherwise false.\n */\nfunction isArray(val) {\n  return objToString.call(val) === '[object Array]';\n}\n\n/**\n * Event emitter constructor.\n *\n * @api public\n */\nfunction EventEmitter() {}\n\n/**\n * Add a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.on = function(name, fn) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = fn;\n  } else if (isArray(this.$events[name])) {\n    this.$events[name].push(fn);\n  } else {\n    this.$events[name] = [this.$events[name], fn];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n/**\n * Adds a volatile listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.once = function(name, fn) {\n  var self = this;\n\n  function on() {\n    self.removeListener(name, on);\n    fn.apply(this, arguments);\n  }\n\n  on.listener = fn;\n  this.on(name, on);\n\n  return this;\n};\n\n/**\n * Remove a listener.\n *\n * @api public\n * @param {string} name Event name.\n * @param {Function} fn Event handler.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeListener = function(name, fn) {\n  if (this.$events && this.$events[name]) {\n    var list = this.$events[name];\n\n    if (isArray(list)) {\n      var pos = -1;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i] === fn || (list[i].listener && list[i].listener === fn)) {\n          pos = i;\n          break;\n        }\n      }\n\n      if (pos < 0) {\n        return this;\n      }\n\n      list.splice(pos, 1);\n\n      if (!list.length) {\n        delete this.$events[name];\n      }\n    } else if (list === fn || (list.listener && list.listener === fn)) {\n      delete this.$events[name];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners for an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.removeAllListeners = function(name) {\n  if (name === undefined) {\n    this.$events = {};\n    return this;\n  }\n\n  if (this.$events && this.$events[name]) {\n    this.$events[name] = null;\n  }\n\n  return this;\n};\n\n/**\n * Get all listeners for a given event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {EventEmitter} Emitter instance.\n */\nEventEmitter.prototype.listeners = function(name) {\n  if (!this.$events) {\n    this.$events = {};\n  }\n\n  if (!this.$events[name]) {\n    this.$events[name] = [];\n  }\n\n  if (!isArray(this.$events[name])) {\n    this.$events[name] = [this.$events[name]];\n  }\n\n  return this.$events[name];\n};\n\n/**\n * Emit an event.\n *\n * @api public\n * @param {string} name Event name.\n * @return {boolean} true if at least one handler was invoked, else false.\n */\nEventEmitter.prototype.emit = function(name) {\n  if (!this.$events) {\n    return false;\n  }\n\n  var handler = this.$events[name];\n\n  if (!handler) {\n    return false;\n  }\n\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  if (typeof handler === 'function') {\n    handler.apply(this, args);\n  } else if (isArray(handler)) {\n    var listeners = handler.slice();\n\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n  } else {\n    return false;\n  }\n\n  return true;\n};\n\n},{}],4:[function(require,module,exports){\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress() {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function(size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function(text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function(size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function(family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function(n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function(ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],5:[function(require,module,exports){\n(function (global){\nexports.isatty = function isatty() {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize() {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(require,module,exports){\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context() {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context}\n */\nContext.prototype.runnable = function(runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function(enabled) {\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function(ms) {\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @return {Context} self\n */\nContext.prototype.skip = function() {\n  this.runnable().skip();\n  return this;\n};\n\n/**\n * Allow a number of retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n/**\n * Inspect the context void of `._runnable`.\n *\n * @api private\n * @return {string}\n */\nContext.prototype.inspect = function() {\n  return JSON.stringify(this, function(key, val) {\n    return key === 'runnable' || key === 'test' ? undefined : val;\n  }, 2);\n};\n\n},{}],7:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook(title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function(err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":35,\"./utils\":39}],8:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function(title, fn) {\n      var suite = context.describe(title, fn);\n      mocha.grep(suite.fullTitle());\n      return suite;\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    var it = context.it = context.specify = function(title, fn) {\n      var suite = suites[0];\n      if (suite.pending) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function(title, fn) {\n      var test = it(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n      return test;\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function(title) {\n      context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function(n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function(suites, context) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root wuite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function(name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function(name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function(name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function(name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    test: {\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function(title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {string} n\n       */\n      retries: function(n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{}],10:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit(obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":37,\"../test\":38}],11:[function(require,module,exports){\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":8,\"./exports\":10,\"./qunit\":12,\"./tdd\":13}],12:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function(title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      return suite;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.suite.only = function(title, fn) {\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function(title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],13:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\nvar escapeRe = require('escape-string-regexp');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function(suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function(context, file, mocha) {\n    var common = require('./common')(suites, context);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.file = file;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n      return suite;\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function(title, fn) {\n      var suite = Suite.create(suites[0], title);\n      suite.pending = true;\n      suites.unshift(suite);\n      fn.call(suite);\n      suites.shift();\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function(title, fn) {\n      var suite = context.suite(title, fn);\n      mocha.grep(suite.fullTitle());\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function(title, fn) {\n      var suite = suites[0];\n      if (suite.pending) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function(title, fn) {\n      var test = context.test(title, fn);\n      var reString = '^' + escapeRe(test.fullTitle()) + '$';\n      mocha.grep(new RegExp(reString));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../suite\":37,\"../test\":38,\"./common\":9,\"escape-string-regexp\":68}],14:[function(require,module,exports){\n(function (process,global,__dirname){\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image(name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @param {Object} options\n * @api public\n */\nfunction Mocha(options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.grep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n\n  this.suite.on('pre-require', function(context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function(file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function(reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        err.message.indexOf('Cannot find module') !== -1\n          ? console.warn('\"' + reporter + '\" reporter not found')\n          : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named '\n        + 'mocha-teamcity-reporter '\n        + '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n *\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function(name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function(fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function(file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function(runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function() {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function(re) {\n  this.options.grep = typeof re === 'string' ? new RegExp(escapeRe(re)) : re;\n  return this;\n};\n\n/**\n * Invert `.grep()` matches.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function() {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function(ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.checkLeaks = function() {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.fullTrace = function() {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.growl = function() {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function(globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function(colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function(inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function(timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.retries = function(n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function(slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function(enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.asyncOnly = function() {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n */\nMocha.prototype.noHighlighting = function() {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.allowUncaught = function() {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay() {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * @api public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function(fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n\n  function done(failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":6,\"./hook\":7,\"./interfaces\":11,\"./reporters\":22,\"./runnable\":35,\"./runner\":36,\"./suite\":37,\"./test\":38,\"./utils\":39,\"_process\":51,\"escape-string-regexp\":68,\"growl\":69,\"path\":41}],15:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @api public\n * @param {string|number} val\n * @param {Object} options\n * @return {string|number}\n */\nmodule.exports = function(val, options) {\n  options = options || {};\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  // https://github.com/mochajs/mocha/pull/1035\n  return options['long'] ? longFormat(val) : shortFormat(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse(str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction shortFormat(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction longFormat(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n *\n * @api private\n * @param {number} ms\n * @param {number} n\n * @param {string} name\n */\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],16:[function(require,module,exports){\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending(message) {\n  this.message = message;\n}\n\n},{}],17:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '',\n  err: '',\n  dot: ''\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function(type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n      ? process.stdout.getWindowSize(1)[0]\n      : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function() {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function() {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function() {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function() {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function() {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\n/**\n * Outut the given `failures` as a list.\n *\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function(failures) {\n  console.log();\n  failures.forEach(function(test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n')\n      + color('error message', '     %s')\n      + color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message) {\n      message = err.message;\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = stack.indexOf(message);\n    var actual = err.actual;\n    var expected = err.expected;\n    var escape = true;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (err.showDiff !== false && sameType(actual, expected) && expected !== undefined) {\n      escape = false;\n      if (!(utils.isString(actual) && utils.isString(expected))) {\n        err.actual = actual = utils.stringify(actual);\n        err.expected = expected = utils.stringify(expected);\n      }\n\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      if (exports.inlineDiffs) {\n        msg += inlineDiff(err, escape);\n      } else {\n        msg += unifiedDiff(err, escape);\n      }\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    console.log(fmt, (i + 1), test.fullTitle(), msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base(runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function() {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function(suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function() {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function(test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function(test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.on('end', function() {\n    stats.end = new Date();\n    stats.duration = new Date() - stats.start;\n  });\n\n  runner.on('pending', function() {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @api public\n */\nBase.prototype.epilogue = function() {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ')\n    + color('green', ' %d passing')\n    + color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ')\n      + color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad(str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} Diff\n */\nfunction inlineDiff(err, escape) {\n  var msg = errorDiff(err, 'WordsWithSpace', escape);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function(str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n'\n    + color('diff removed', 'actual')\n    + ' '\n    + color('diff added', 'expected')\n    + '\\n\\n'\n    + msg\n    + '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings.\n *\n * @api private\n * @param {Error} err with actual/expected\n * @param {boolean} escape\n * @return {string} The diff.\n */\nfunction unifiedDiff(err, escape) {\n  var indent = '      ';\n  function cleanUp(line) {\n    if (escape) {\n      line = escapeInvisibles(line);\n    }\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/\\@\\@/)) {\n      return null;\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank(line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', err.actual, err.expected);\n  var lines = msg.split('\\n').splice(4);\n  return '\\n      '\n    + colorLines('diff added', '+ expected') + ' '\n    + colorLines('diff removed', '- actual')\n    + '\\n\\n'\n    + lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {Error} err\n * @param {string} type\n * @param {boolean} escape\n * @return {string}\n */\nfunction errorDiff(err, type, escape) {\n  var actual = escape ? escapeInvisibles(err.actual) : err.actual;\n  var expected = escape ? escapeInvisibles(err.expected) : err.expected;\n  return diff['diff' + type](actual, expected).map(function(str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Returns a string with all invisible characters in plain text\n *\n * @api private\n * @param {string} line\n * @return {string}\n */\nfunction escapeInvisibles(line) {\n  return line.replace(/\\t/g, '<tab>')\n    .replace(/\\r/g, '<CR>')\n    .replace(/\\n/g, '<LF>\\n');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines(name, str) {\n  return str.split('\\n').map(function(str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType(a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":15,\"../utils\":39,\"_process\":51,\"diff\":67,\"supports-color\":41,\"tty\":5}],18:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @param {Runner} runner\n * @api public\n */\nfunction Doc(runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function(test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function(test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.fn.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":39,\"./base\":17}],19:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Dot(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var n = -1;\n\n  runner.on('start', function() {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.dot));\n  });\n\n  runner.on('pass', function(test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function() {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.dot));\n  });\n\n  runner.on('end', function() {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],20:[function(require,module,exports){\n(function (process,__dirname){\n/**\n * Module dependencies.\n */\n\nvar JSONCov = require('./json-cov');\nvar readFileSync = require('fs').readFileSync;\nvar join = require('path').join;\n\n/**\n * Expose `HTMLCov`.\n */\n\nexports = module.exports = HTMLCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTMLCov(runner) {\n  var jade = require('jade');\n  var file = join(__dirname, '/templates/coverage.jade');\n  var str = readFileSync(file, 'utf8');\n  var fn = jade.compile(str, { filename: file });\n  var self = this;\n\n  JSONCov.call(this, runner, false);\n\n  runner.on('end', function() {\n    process.stdout.write(fn({\n      cov: self.cov,\n      coverageClass: coverageClass\n    }));\n  });\n}\n\n/**\n * Return coverage class for a given coverage percentage.\n *\n * @api private\n * @param {number} coveragePctg\n * @return {string}\n */\nfunction coverageClass(coveragePctg) {\n  if (coveragePctg >= 75) {\n    return 'high';\n  }\n  if (coveragePctg >= 50) {\n    return 'medium';\n  }\n  if (coveragePctg >= 25) {\n    return 'low';\n  }\n  return 'terrible';\n}\n\n}).call(this,require('_process'),\"/lib/reporters\")\n},{\"./json-cov\":23,\"_process\":51,\"fs\":41,\"jade\":41,\"path\":41}],21:[function(require,module,exports){\n(function (global){\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">'\n  + '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>'\n  + '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>'\n  + '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>'\n  + '<li class=\"duration\">duration: <em>0</em>s</li>'\n  + '</ul>';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction HTML(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function() {\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function() {\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function(suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function(suite) {\n    if (suite.root) {\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('fail', function(test) {\n    // For type = 'test' its possible that the test failed due to multiple\n    // done() calls. So report the issue here.\n    if (test.type === 'hook'\n      || test.type === 'test') {\n      runner.emit('test end', test);\n    }\n  });\n\n  runner.on('test end', function(test) {\n    // TODO: add to stats\n    var percent = stats.tests / this.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n\n    // test\n    var el;\n    if (test.state === 'passed') {\n      var url = self.testURL(test);\n      el = fragment('<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> <a href=\"%s\" class=\"replay\"></a></h2></li>', test.speed, test.title, test.duration, url);\n    } else if (test.pending) {\n      el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    } else {\n      el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\"></a></h2></li>', test.title, self.testURL(test));\n      var stackString; // Note: Includes leading newline\n      var message = test.err.toString();\n\n      // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n      // check for the result of the stringifying.\n      if (message === '[object Error]') {\n        message = test.err.message;\n      }\n\n      if (test.err.stack) {\n        var indexOfMessage = test.err.stack.indexOf(test.err.message);\n        if (indexOfMessage === -1) {\n          stackString = test.err.stack;\n        } else {\n          stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n        }\n      } else if (test.err.sourceURL && test.err.line !== undefined) {\n        // Safari doesn't give you a stack. Let's at least provide a source line.\n        stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n      }\n\n      stackString = stackString || '';\n\n      if (test.err.htmlMessage && stackString) {\n        el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>', test.err.htmlMessage, stackString));\n      } else if (test.err.htmlMessage) {\n        el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n      } else {\n        el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n      }\n    }\n\n    // toggle code\n    // TODO: defer\n    if (!test.pending) {\n      var h2 = el.getElementsByTagName('h2')[0];\n\n      on(h2, 'click', function() {\n        pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n      });\n\n      var pre = fragment('<pre><code>%e</code></pre>', utils.clean(test.body));\n      el.appendChild(pre);\n      pre.style.display = 'none';\n    }\n\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  });\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl(s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function(suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function(test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error(msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment(html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function(_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout(classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide() {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text(el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on(el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":4,\"../utils\":39,\"./base\":17,\"escape-string-regexp\":68}],22:[function(require,module,exports){\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONCov = exports['json-cov'] = require('./json-cov');\nexports.HTMLCov = exports['html-cov'] = require('./html-cov');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":17,\"./doc\":18,\"./dot\":19,\"./html\":21,\"./html-cov\":20,\"./json\":25,\"./json-cov\":23,\"./json-stream\":24,\"./landing\":26,\"./list\":27,\"./markdown\":28,\"./min\":29,\"./nyan\":30,\"./progress\":31,\"./spec\":32,\"./tap\":33,\"./xunit\":34}],23:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSONCov`.\n */\n\nexports = module.exports = JSONCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {boolean} output\n */\nfunction JSONCov(runner, output) {\n  Base.call(this, runner);\n\n  output = arguments.length === 1 || output;\n  var self = this;\n  var tests = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('end', function() {\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n    if (!output) {\n      return;\n    }\n    process.stdout.write(JSON.stringify(result, null, 2));\n  });\n}\n\n/**\n * Map jscoverage data to a JSON structure\n * suitable for reporting.\n *\n * @api private\n * @param {Object} cov\n * @return {Object}\n */\n\nfunction map(cov) {\n  var ret = {\n    instrumentation: 'node-jscoverage',\n    sloc: 0,\n    hits: 0,\n    misses: 0,\n    coverage: 0,\n    files: []\n  };\n\n  for (var filename in cov) {\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\n      var data = coverage(filename, cov[filename]);\n      ret.files.push(data);\n      ret.hits += data.hits;\n      ret.misses += data.misses;\n      ret.sloc += data.sloc;\n    }\n  }\n\n  ret.files.sort(function(a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = (ret.hits / ret.sloc) * 100;\n  }\n\n  return ret;\n}\n\n/**\n * Map jscoverage data for a single source file\n * to a JSON structure suitable for reporting.\n *\n * @api private\n * @param {string} filename name of the source file\n * @param {Object} data jscoverage coverage data\n * @return {Object}\n */\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n\n  data.source.forEach(function(line, num) {\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n      source: line,\n      coverage: data[num] === undefined ? '' : data[num]\n    };\n  });\n\n  ret.coverage = ret.hits / ret.sloc * 100;\n\n  return ret;\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    fullTitle: test.fullTitle(),\n    title: test.title\n  };\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./base\":17,\"_process\":51}],24:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function() {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function(test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function(test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.on('end', function() {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":51}],25:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function(test) {\n    pending.push(test);\n  });\n\n  runner.on('end', function() {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: errorJSON(test.err || {})\n  };\n}\n\n/**\n * Transform `error` into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON(err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function(key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":17,\"_process\":51}],26:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Landing(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '');\n  var crashed = -1;\n  var n = 0;\n\n  function runway() {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function() {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function(test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.on('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],27:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction List(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('test', function(test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = color('checkmark', '  -')\n      + color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function(test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.dot)\n      + color('pass', ' %s: ')\n      + color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function(test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],28:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown(runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title(str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC(suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function(suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC(obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC(suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function(suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function() {\n    --level;\n  });\n\n  runner.on('pass', function(test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.on('end', function() {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],29:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Min(runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function() {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.on('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],30:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n */\n\nfunction NyanCat(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function() {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function() {\n    self.draw();\n  });\n\n  runner.on('pass', function() {\n    self.draw();\n  });\n\n  runner.on('fail', function() {\n    self.draw();\n  });\n\n  runner.on('end', function() {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function() {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function() {\n  var stats = this.stats;\n\n  function draw(type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function() {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function() {\n  var self = this;\n\n  this.trajectories.forEach(function(line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function() {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function() {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function(n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function(n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function() {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function(str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write(string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],31:[function(require,module,exports){\n(function (process){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress(runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * .50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  options.open = options.open || '[';\n  options.complete = options.complete || '';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n\n  // tests started\n  runner.on('start', function() {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function() {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.on('end', function() {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":39,\"./base\":17,\"_process\":51}],32:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction Spec(runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent() {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function() {\n    console.log();\n  });\n\n  runner.on('suite', function(suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function() {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function(test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function(test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s');\n      cursor.CR();\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent()\n        + color('checkmark', '  ' + Base.symbols.ok)\n        + color('pass', ' %s')\n        + color(test.speed, ' (%dms)');\n      cursor.CR();\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function(test) {\n    cursor.CR();\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.on('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":39,\"./base\":17}],33:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction TAP(runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function() {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function() {\n    ++n;\n  });\n\n  runner.on('pending', function(test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function(test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function(test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.on('end', function() {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title(test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":17}],34:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit(runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  if (options.reporterOptions && options.reporterOptions.output) {\n    if (!fs.createWriteStream) {\n      throw new Error('file output not supported in browser');\n    }\n    mkdirp.sync(path.dirname(options.reporterOptions.output));\n    self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n  }\n\n  runner.on('pending', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('end', function() {\n    self.write(tag('testsuite', {\n      name: 'Mocha Tests',\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function(t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function(failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function() {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function(line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function(test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, cdata(escape(err.message) + '\\n' + err.stack))));\n  } else if (test.pending) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag(name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n/**\n * Return cdata escaped CDATA `str`.\n */\n\nfunction cdata(str) {\n  return '<![CDATA[' + escape(str) + ']]>';\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":39,\"./base\":17,\"_process\":51,\"fs\":41,\"mkdirp\":70,\"path\":41}],35:[function(require,module,exports){\n(function (global){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.\n *\n * @param {String} title\n * @param {Function} fn\n * @api private\n * @param {string} title\n * @param {Function} fn\n */\nfunction Runnable(title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._trace = new Error('done() called multiple times');\n  this._retries = -1;\n  this._currentRetry = 0;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms === 0) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set & get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @api private\n */\nRunnable.prototype.skip = function() {\n  throw new Pending();\n};\n\n/**\n * Set number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function(n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function() {\n  return this.parent.fullTitle() + ' ' + this.title;\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function() {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function() {\n  return JSON.stringify(this, function(key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function() {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function() {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.'));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Whitelist a list of globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function(globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function(fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple(err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    self.emit('error', err || new Error('done() called multiple times; stacktrace may be inaccurate'));\n  }\n\n  // finished\n  function done(err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n    if (finished) {\n      return multiple(err || self._trace);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = new Error('timeout of ' + ms + 'ms exceeded. Ensure the done() callback is being called in this test.');\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    callFn(this.fn);\n    done();\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.pending) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    done(utils.getError(err));\n  }\n\n  function callFn(fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function() {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function(reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync(fn) {\n    fn.call(ctx, function(err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: '\n            + JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      done();\n    });\n  }\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":15,\"./pending\":16,\"./utils\":39,\"debug\":2,\"events\":3}],36:[function(require,module,exports){\n(function (process,global){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @api public\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function(hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function(re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function() {\n  var props = keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function(arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function(test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function(test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = (this.fullStackTrace || !err.stack)\n    ? err.stack\n    : stackFilter(err.stack);\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function(hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function(name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function(err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function() {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function(name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function(name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function(name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function() {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function(fn) {\n  var self = this;\n  var test = this.test;\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.on('error', function(err) {\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function(suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep  It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    function parentPending(suite) {\n      return suite.pending || (suite.parent && parentPending(suite.parent));\n    }\n\n    // pending\n    if (test.pending || parentPending(test.parent)) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function(err, errSuite) {\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function(err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function(suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function() {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function() {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function(err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function(err) {\n  if (err) {\n    debug('uncaught exception %s', err !== function() {\n      return this;\n    }.call(err) ? err : (err.message || err));\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete\n  if (runnable.state) {\n    return;\n  }\n  this.fail(runnable, err);\n\n  // recover from test\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n // recover from hooks\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences(suite) {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function(fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function() {};\n\n  function uncaught(err) {\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function() {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function() {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function() {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function(key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function(ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals() {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function(a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":16,\"./runnable\":35,\"./utils\":39,\"_process\":51,\"debug\":2,\"events\":3}],37:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function(parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  if (parent.pending) {\n    suite.pending = true;\n  }\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`.\n *\n * @api private\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite(title, parentContext) {\n  this.title = title;\n  function Context() {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function() {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function(ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function(n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function(enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function(ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Sets whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function(bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function(title, fn) {\n  if (this.pending) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function(suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function(test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function() {\n  if (this.parent) {\n    var full = this.parent.fullTitle();\n    if (full) {\n      return full + ' ' + this.title;\n    }\n  }\n  return this.title;\n};\n\n/**\n * Return the total number of tests.\n *\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function() {\n  return utils.reduce(this.suites, function(sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function(fn) {\n  utils.forEach(this.tests, fn);\n  utils.forEach(this.suites, function(suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run() {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":7,\"./ms\":15,\"./utils\":39,\"debug\":2,\"events\":3}],38:[function(require,module,exports){\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test(title, fn) {\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n  this.body = (fn || '').toString();\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Test, Runnable);\n\nTest.prototype.clone = function() {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":35,\"./utils\":39}],39:[function(require,module,exports){\n(function (process,Buffer){\n/* eslint-env browser */\n\n/**\n * Module dependencies.\n */\n\nvar basename = require('path').basename;\nvar debug = require('debug')('mocha:watch');\nvar exists = require('fs').existsSync || require('path').existsSync;\nvar glob = require('glob');\nvar join = require('path').join;\nvar readdirSync = require('fs').readdirSync;\nvar statSync = require('fs').statSync;\nvar watchFile = require('fs').watchFile;\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function(html) {\n  return String(html)\n    .replace(/&/g, '&amp;')\n    .replace(/\"/g, '&quot;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;');\n};\n\n/**\n * Array#forEach (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n */\nexports.forEach = function(arr, fn, scope) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    fn.call(scope, arr[i], i);\n  }\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function(obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Array#map (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} scope\n * @return {Array}\n */\nexports.map = function(arr, fn, scope) {\n  var result = [];\n  for (var i = 0, l = arr.length; i < l; i++) {\n    result.push(fn.call(scope, arr[i], i, arr));\n  }\n  return result;\n};\n\n/**\n * Array#indexOf (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Object} obj to find index of\n * @param {number} start\n * @return {number}\n */\nexports.indexOf = function(arr, obj, start) {\n  for (var i = start || 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Array#reduce (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object} val Initial value.\n * @return {*}\n */\nexports.reduce = function(arr, fn, val) {\n  var rval = val;\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    rval = fn(rval, arr[i], i, arr);\n  }\n\n  return rval;\n};\n\n/**\n * Array#filter (<=IE8)\n *\n * @api private\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nexports.filter = function(arr, fn) {\n  var ret = [];\n\n  for (var i = 0, l = arr.length; i < l; i++) {\n    var val = arr[i];\n    if (fn(val, i, arr)) {\n      ret.push(val);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Object.keys (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Array} keys\n */\nexports.keys = typeof Object.keys === 'function' ? Object.keys : function(obj) {\n  var keys = [];\n  var has = Object.prototype.hasOwnProperty; // for `window` on <=IE8\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function(files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function(file) {\n    debug('file %s', file);\n    watchFile(file, options, function(curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Array.isArray (<=IE8)\n *\n * @api private\n * @param {Object} obj\n * @return {Boolean}\n */\nvar isArray = typeof Array.isArray === 'function' ? Array.isArray : function(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nexports.isArray = isArray;\n\n/**\n * Buffer.prototype.toJSON polyfill.\n *\n * @type {Function}\n */\nif (typeof Buffer !== 'undefined' && Buffer.prototype) {\n  Buffer.prototype.toJSON = Buffer.prototype.toJSON || function() {\n    return Array.prototype.slice.call(this, 0);\n  };\n}\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored(path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function(dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  readdirSync(dir)\n    .filter(ignored)\n    .forEach(function(path) {\n      path = join(dir, path);\n      if (statSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function(str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function(str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    .replace(/^function *\\(.*\\)\\s*\\{|\\(.*\\) *=> *\\{?/, '')\n    .replace(/\\s+\\}$/, '');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs ? tabs : spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return exports.trim(str);\n};\n\n/**\n * Trim the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.trim = function(str) {\n  return str.replace(/^\\s+|\\s+$/g, '');\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function(qs) {\n  return exports.reduce(qs.replace('?', '').split('&'), function(obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    obj[key] = decodeURIComponent(val);\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight(js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function(name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} [type] The type of the value, if known.\n * @returns {string}\n */\nfunction emptyRepresentation(value, type) {\n  type = type || exports.type(value);\n\n  switch (type) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string}\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n */\nexports.type = function type(value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)\\]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function(value) {\n  var type = exports.type(value);\n\n  if (!~exports.indexOf(['object', 'array', 'function'], type)) {\n    if (type !== 'buffer') {\n      return jsonStringify(value);\n    }\n    var json = value.toJSON();\n    // Based on the toJSON result\n    return jsonStringify(json.data && json.type ? json.data : json, 2)\n      .replace(/,(\\n|$)/g, '$1');\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, type);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify(object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = isArray(object) ? '[' : '{';\n  var end = isArray(object) ? ']' : '}';\n  var length = object.length || exports.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat(s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify(val) {\n    switch (exports.type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime())        // Invalid date\n          ? val.toString()\n          : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!object.hasOwnProperty(i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space)\n      + (isArray(object) ? '' : '\"' + i + '\": ') // key\n      + _stringify(object[i])                     // value\n      + (length ? ',' : '');                     // comma\n  }\n\n  return str\n    // [], {}\n    + (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Test if a value is a buffer.\n *\n * @api private\n * @param {*} value The value to test.\n * @return {boolean} True if `value` is a buffer, otherwise false\n */\nexports.isBuffer = function(value) {\n  return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);\n};\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function(value, stack) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  var type = exports.type(value);\n  function withStack(value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (exports.indexOf(stack, value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (type) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function() {\n        canonicalizedObj = exports.map(value, function(item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, type);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function() {\n        exports.forEach(exports.keys(value).sort(), function(key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @api public\n * @param {string} path Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles(path, extensions, recursive) {\n  var files = [];\n  var re = new RegExp('\\\\.(' + extensions.join('|') + ')$');\n\n  if (!exists(path)) {\n    if (exists(path + '.js')) {\n      path += '.js';\n    } else {\n      files = glob.sync(path);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + path + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = statSync(path);\n    if (stat.isFile()) {\n      return path;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  readdirSync(path).forEach(function(file) {\n    file = join(path, file);\n    try {\n      var stat = statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    if (!stat.isFile() || !re.test(file) || basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function() {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function(err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function() {\n  // TODO: Replace with `process.browser`\n  var slash = '/';\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var cwd = is.node\n      ? process.cwd() + slash\n      : (typeof location === 'undefined' ? window.location : location).href.replace(/\\/[^\\/]*$/, '/');\n\n  function isMochaInternal(line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash))\n      || (~line.indexOf('components' + slash + 'mochajs' + slash))\n      || (~line.indexOf('components' + slash + 'mocha' + slash))\n      || (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal(line) {\n    return (~line.indexOf('(timers.js:'))\n      || (~line.indexOf('(events.js:'))\n      || (~line.indexOf('(node.js:'))\n      || (~line.indexOf('(module.js:'))\n      || (~line.indexOf('GeneratorFunctionPrototype.next (native)'))\n      || false;\n  }\n\n  return function(stack) {\n    stack = stack.split('\\n');\n\n    stack = exports.reduce(stack, function(list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      list.push(line.replace(cwd, ''));\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":51,\"buffer\":43,\"debug\":2,\"fs\":41,\"glob\":41,\"path\":41,\"util\":66}],40:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"stream\":63,\"util\":66}],41:[function(require,module,exports){\n\n},{}],42:[function(require,module,exports){\narguments[4][41][0].apply(exports,arguments)\n},{\"dup\":41}],43:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = (function () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n},{\"base64-js\":44,\"ieee754\":45,\"is-array\":46}],44:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n	'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n	var PLUS   = '+'.charCodeAt(0)\n	var SLASH  = '/'.charCodeAt(0)\n	var NUMBER = '0'.charCodeAt(0)\n	var LOWER  = 'a'.charCodeAt(0)\n	var UPPER  = 'A'.charCodeAt(0)\n	var PLUS_URL_SAFE = '-'.charCodeAt(0)\n	var SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n	function decode (elt) {\n		var code = elt.charCodeAt(0)\n		if (code === PLUS ||\n		    code === PLUS_URL_SAFE)\n			return 62 // '+'\n		if (code === SLASH ||\n		    code === SLASH_URL_SAFE)\n			return 63 // '/'\n		if (code < NUMBER)\n			return -1 //no match\n		if (code < NUMBER + 10)\n			return code - NUMBER + 26 + 26\n		if (code < UPPER + 26)\n			return code - UPPER\n		if (code < LOWER + 26)\n			return code - LOWER + 26\n	}\n\n	function b64ToByteArray (b64) {\n		var i, j, l, tmp, placeHolders, arr\n\n		if (b64.length % 4 > 0) {\n			throw new Error('Invalid string. Length must be a multiple of 4')\n		}\n\n		// the number of equal signs (place holders)\n		// if there are two placeholders, than the two characters before it\n		// represent one byte\n		// if there is only one, then the three characters before it represent 2 bytes\n		// this is just a cheap hack to not do indexOf twice\n		var len = b64.length\n		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n		// base64 is 4/3 + up to two characters of the original data\n		arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n		// if there are placeholders, only get up to the last complete 4 chars\n		l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n		var L = 0\n\n		function push (v) {\n			arr[L++] = v\n		}\n\n		for (i = 0, j = 0; i < l; i += 4, j += 3) {\n			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n			push((tmp & 0xFF0000) >> 16)\n			push((tmp & 0xFF00) >> 8)\n			push(tmp & 0xFF)\n		}\n\n		if (placeHolders === 2) {\n			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n			push(tmp & 0xFF)\n		} else if (placeHolders === 1) {\n			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n			push((tmp >> 8) & 0xFF)\n			push(tmp & 0xFF)\n		}\n\n		return arr\n	}\n\n	function uint8ToBase64 (uint8) {\n		var i,\n			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n			output = \"\",\n			temp, length\n\n		function encode (num) {\n			return lookup.charAt(num)\n		}\n\n		function tripletToBase64 (num) {\n			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n		}\n\n		// go through the array every three bytes, we'll deal with trailing stuff later\n		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n			output += tripletToBase64(temp)\n		}\n\n		// pad the end with zeros, but make sure to not forget the extra bytes\n		switch (extraBytes) {\n			case 1:\n				temp = uint8[uint8.length - 1]\n				output += encode(temp >> 2)\n				output += encode((temp << 4) & 0x3F)\n				output += '=='\n				break\n			case 2:\n				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n				output += encode(temp >> 10)\n				output += encode((temp >> 4) & 0x3F)\n				output += encode((temp << 2) & 0x3F)\n				output += '='\n				break\n		}\n\n		return output\n	}\n\n	exports.toByteArray = b64ToByteArray\n	exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],45:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],46:[function(require,module,exports){\n\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],48:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],49:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],50:[function(require,module,exports){\nexports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n},{}],51:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],52:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":53}],53:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":55,\"./_stream_writable\":57,\"_process\":51,\"core-util-is\":58,\"inherits\":48}],54:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":56,\"core-util-is\":58,\"inherits\":48}],55:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":53,\"_process\":51,\"buffer\":43,\"core-util-is\":58,\"events\":47,\"inherits\":48,\"isarray\":49,\"stream\":63,\"string_decoder/\":64,\"util\":42}],56:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":53,\"core-util-is\":58,\"inherits\":48}],57:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":53,\"_process\":51,\"buffer\":43,\"core-util-is\":58,\"inherits\":48,\"stream\":63}],58:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":43}],59:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":54}],60:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":53,\"./lib/_stream_passthrough.js\":54,\"./lib/_stream_readable.js\":55,\"./lib/_stream_transform.js\":56,\"./lib/_stream_writable.js\":57,\"stream\":63}],61:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":56}],62:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":57}],63:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":48,\"readable-stream/duplex.js\":52,\"readable-stream/passthrough.js\":59,\"readable-stream/readable.js\":60,\"readable-stream/transform.js\":61,\"readable-stream/writable.js\":62}],64:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":43}],65:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],66:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":65,\"_process\":51,\"inherits\":48}],67:[function(require,module,exports){\n/* See LICENSE file for terms of use */\n\n/*\n * Text diff implementation.\n *\n * This library supports the following APIS:\n * JsDiff.diffChars: Character by character diff\n * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n * JsDiff.diffLines: Line based diff\n *\n * JsDiff.diffCss: Diff targeted at CSS content\n *\n * These methods are based on the implementation proposed in\n * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n */\n(function(global, undefined) {\n  var objectPrototypeToString = Object.prototype.toString;\n\n  /*istanbul ignore next*/\n  function map(arr, mapper, that) {\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, mapper, that);\n    }\n\n    var other = new Array(arr.length);\n\n    for (var i = 0, n = arr.length; i < n; i++) {\n      other[i] = mapper.call(that, arr[i], i, arr);\n    }\n    return other;\n  }\n  function clonePath(path) {\n    return { newPos: path.newPos, components: path.components.slice(0) };\n  }\n  function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  }\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n\n    return n;\n  }\n\n  // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed.\n  function canonicalize(obj, stack, replacementStack) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else if (typeof obj === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n      var sortedKeys = [],\n          key;\n      for (key in obj) {\n        sortedKeys.push(key);\n      }\n      sortedKeys.sort();\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        key = sortedKeys[i];\n        canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);\n      }\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n    return canonicalizedObj;\n  }\n\n  function buildValues(components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = map(value, function(value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n\n          component.value = value.join('');\n        } else {\n          component.value = newString.slice(newPos, newPos + component.count).join('');\n        }\n        newPos += component.count;\n\n        // Common case\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = oldString.slice(oldPos, oldPos + component.count).join('');\n        oldPos += component.count;\n\n        // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    }\n\n    return components;\n  }\n\n  function Diff(ignoreWhitespace) {\n    this.ignoreWhitespace = ignoreWhitespace;\n  }\n  Diff.prototype = {\n    diff: function(oldString, newString, callback) {\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function() { callback(undefined, value); }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      }\n\n      // Handle the identity case (this is due to unrolling editLength == 0\n      if (newString === oldString) {\n        return done([{ value: newString }]);\n      }\n      if (!newString) {\n        return done([{ value: oldString, removed: true }]);\n      }\n      if (!oldString) {\n        return done([{ value: newString, added: true }]);\n      }\n\n      newString = this.tokenize(newString);\n      oldString = this.tokenize(oldString);\n\n      var newLen = newString.length, oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{ newPos: -1, components: [] }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{value: newString.join('')}]);\n      }\n\n      // Main worker method. checks all permutations of a given edit length for acceptance.\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath;\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          }\n\n          // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n          if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath;   // No need to clone, we've pulled it from the list\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n          // If we have hit the end of both strings, then we are done\n          if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n            return done(buildValues(basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n      if (callback) {\n        (function exec() {\n          setTimeout(function() {\n            // This should not happen, but we want to be safe.\n            /*istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        }());\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n\n    pushComponent: function(components, added, removed) {\n      var last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n      } else {\n        components.push({count: 1, added: added, removed: removed });\n      }\n    },\n    extractCommon: function(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n\n          commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({count: commonCount});\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n\n    equals: function(left, right) {\n      var reWhitespace = /\\S/;\n      return left === right || (this.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right));\n    },\n    tokenize: function(value) {\n      return value.split('');\n    }\n  };\n\n  var CharDiff = new Diff();\n\n  var WordDiff = new Diff(true);\n  var WordWithSpaceDiff = new Diff();\n  WordDiff.tokenize = WordWithSpaceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\s+|\\b)/));\n  };\n\n  var CssDiff = new Diff(true);\n  CssDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/([{}:;,]|\\s+)/));\n  };\n\n  var LineDiff = new Diff();\n\n  var TrimmedLineDiff = new Diff();\n  TrimmedLineDiff.ignoreTrim = true;\n\n  LineDiff.tokenize = TrimmedLineDiff.tokenize = function(value) {\n    var retLines = [],\n        lines = value.split(/^/m);\n    for (var i = 0; i < lines.length; i++) {\n      var line = lines[i],\n          lastLine = lines[i - 1],\n          lastLineLastChar = lastLine && lastLine[lastLine.length - 1];\n\n      // Merge lines that may contain windows new lines\n      if (line === '\\n' && lastLineLastChar === '\\r') {\n          retLines[retLines.length - 1] = retLines[retLines.length - 1].slice(0, -1) + '\\r\\n';\n      } else {\n        if (this.ignoreTrim) {\n          line = line.trim();\n          // add a newline unless this is the last line.\n          if (i < lines.length - 1) {\n            line += '\\n';\n          }\n        }\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  var PatchDiff = new Diff();\n  PatchDiff.tokenize = function(value) {\n    var ret = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n    // Ignore the final empty token that occurs if the string ends with a new line\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    }\n\n    // Merge the content and line separators into single tokens\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2) {\n        ret[ret.length - 1] += line;\n      } else {\n        ret.push(line);\n      }\n    }\n    return ret;\n  };\n\n  var SentenceDiff = new Diff();\n  SentenceDiff.tokenize = function(value) {\n    return removeEmpty(value.split(/(\\S.+?[.!?])(?=\\s+|$)/));\n  };\n\n  var JsonDiff = new Diff();\n  // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n  JsonDiff.useLongestToken = true;\n  JsonDiff.tokenize = LineDiff.tokenize;\n  JsonDiff.equals = function(left, right) {\n    return LineDiff.equals(left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  var JsDiff = {\n    Diff: Diff,\n\n    diffChars: function(oldStr, newStr, callback) { return CharDiff.diff(oldStr, newStr, callback); },\n    diffWords: function(oldStr, newStr, callback) { return WordDiff.diff(oldStr, newStr, callback); },\n    diffWordsWithSpace: function(oldStr, newStr, callback) { return WordWithSpaceDiff.diff(oldStr, newStr, callback); },\n    diffLines: function(oldStr, newStr, callback) { return LineDiff.diff(oldStr, newStr, callback); },\n    diffTrimmedLines: function(oldStr, newStr, callback) { return TrimmedLineDiff.diff(oldStr, newStr, callback); },\n\n    diffSentences: function(oldStr, newStr, callback) { return SentenceDiff.diff(oldStr, newStr, callback); },\n\n    diffCss: function(oldStr, newStr, callback) { return CssDiff.diff(oldStr, newStr, callback); },\n    diffJson: function(oldObj, newObj, callback) {\n      return JsonDiff.diff(\n        typeof oldObj === 'string' ? oldObj : JSON.stringify(canonicalize(oldObj), undefined, '  '),\n        typeof newObj === 'string' ? newObj : JSON.stringify(canonicalize(newObj), undefined, '  '),\n        callback\n      );\n    },\n\n    createTwoFilesPatch: function(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader) {\n      var ret = [];\n\n      if (oldFileName == newFileName) {\n        ret.push('Index: ' + oldFileName);\n      }\n      ret.push('===================================================================');\n      ret.push('--- ' + oldFileName + (typeof oldHeader === 'undefined' ? '' : '\\t' + oldHeader));\n      ret.push('+++ ' + newFileName + (typeof newHeader === 'undefined' ? '' : '\\t' + newHeader));\n\n      var diff = PatchDiff.diff(oldStr, newStr);\n      diff.push({value: '', lines: []});   // Append an empty value to make cleanup easier\n\n      // Formats a given set of lines for printing as context lines in a patch\n      function contextLines(lines) {\n        return map(lines, function(entry) { return ' ' + entry; });\n      }\n\n      // Outputs the no newline at end of file warning if needed\n      function eofNL(curRange, i, current) {\n        var last = diff[diff.length - 2],\n            isLast = i === diff.length - 2,\n            isLastOfType = i === diff.length - 3 && current.added !== last.added;\n\n        // Figure out if this is the last line for the given file and missing NL\n        if (!(/\\n$/.test(current.value)) && (isLast || isLastOfType)) {\n          curRange.push('\\\\ No newline at end of file');\n        }\n      }\n\n      var oldRangeStart = 0, newRangeStart = 0, curRange = [],\n          oldLine = 1, newLine = 1;\n      for (var i = 0; i < diff.length; i++) {\n        var current = diff[i],\n            lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n        current.lines = lines;\n\n        if (current.added || current.removed) {\n          // If we have previous context, start with that\n          if (!oldRangeStart) {\n            var prev = diff[i - 1];\n            oldRangeStart = oldLine;\n            newRangeStart = newLine;\n\n            if (prev) {\n              curRange = contextLines(prev.lines.slice(-4));\n              oldRangeStart -= curRange.length;\n              newRangeStart -= curRange.length;\n            }\n          }\n\n          // Output our changes\n          curRange.push.apply(curRange, map(lines, function(entry) {\n            return (current.added ? '+' : '-') + entry;\n          }));\n          eofNL(curRange, i, current);\n\n          // Track the updated file position\n          if (current.added) {\n            newLine += lines.length;\n          } else {\n            oldLine += lines.length;\n          }\n        } else {\n          // Identical context lines. Track line changes\n          if (oldRangeStart) {\n            // Close out any changes that have been output (or join overlapping)\n            if (lines.length <= 8 && i < diff.length - 2) {\n              // Overlapping\n              curRange.push.apply(curRange, contextLines(lines));\n            } else {\n              // end the range and output\n              var contextSize = Math.min(lines.length, 4);\n              ret.push(\n                  '@@ -' + oldRangeStart + ',' + (oldLine - oldRangeStart + contextSize)\n                  + ' +' + newRangeStart + ',' + (newLine - newRangeStart + contextSize)\n                  + ' @@');\n              ret.push.apply(ret, curRange);\n              ret.push.apply(ret, contextLines(lines.slice(0, contextSize)));\n              if (lines.length <= 4) {\n                eofNL(ret, i, current);\n              }\n\n              oldRangeStart = 0;\n              newRangeStart = 0;\n              curRange = [];\n            }\n          }\n          oldLine += lines.length;\n          newLine += lines.length;\n        }\n      }\n\n      return ret.join('\\n') + '\\n';\n    },\n\n    createPatch: function(fileName, oldStr, newStr, oldHeader, newHeader) {\n      return JsDiff.createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader);\n    },\n\n    applyPatch: function(oldStr, uniDiff) {\n      var diffstr = uniDiff.split('\\n'),\n          hunks = [],\n          i = 0,\n          remEOFNL = false,\n          addEOFNL = false;\n\n      // Skip to the first change hunk\n      while (i < diffstr.length && !(/^@@/.test(diffstr[i]))) {\n        i++;\n      }\n\n      // Parse the unified diff\n      for (; i < diffstr.length; i++) {\n        if (diffstr[i][0] === '@') {\n          var chnukHeader = diffstr[i].split(/@@ -(\\d+),(\\d+) \\+(\\d+),(\\d+) @@/);\n          hunks.unshift({\n            start: chnukHeader[3],\n            oldlength: +chnukHeader[2],\n            removed: [],\n            newlength: chnukHeader[4],\n            added: []\n          });\n        } else if (diffstr[i][0] === '+') {\n          hunks[0].added.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '-') {\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === ' ') {\n          hunks[0].added.push(diffstr[i].substr(1));\n          hunks[0].removed.push(diffstr[i].substr(1));\n        } else if (diffstr[i][0] === '\\\\') {\n          if (diffstr[i - 1][0] === '+') {\n            remEOFNL = true;\n          } else if (diffstr[i - 1][0] === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n\n      // Apply the diff to the input\n      var lines = oldStr.split('\\n');\n      for (i = hunks.length - 1; i >= 0; i--) {\n        var hunk = hunks[i];\n        // Sanity check the input string. Bail if we don't match.\n        for (var j = 0; j < hunk.oldlength; j++) {\n          if (lines[hunk.start - 1 + j] !== hunk.removed[j]) {\n            return false;\n          }\n        }\n        Array.prototype.splice.apply(lines, [hunk.start - 1, hunk.oldlength].concat(hunk.added));\n      }\n\n      // Handle EOFNL insertion/removal\n      if (remEOFNL) {\n        while (!lines[lines.length - 1]) {\n          lines.pop();\n        }\n      } else if (addEOFNL) {\n        lines.push('');\n      }\n      return lines.join('\\n');\n    },\n\n    convertChangesToXML: function(changes) {\n      var ret = [];\n      for (var i = 0; i < changes.length; i++) {\n        var change = changes[i];\n        if (change.added) {\n          ret.push('<ins>');\n        } else if (change.removed) {\n          ret.push('<del>');\n        }\n\n        ret.push(escapeHTML(change.value));\n\n        if (change.added) {\n          ret.push('</ins>');\n        } else if (change.removed) {\n          ret.push('</del>');\n        }\n      }\n      return ret.join('');\n    },\n\n    // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n    convertChangesToDMP: function(changes) {\n      var ret = [],\n          change,\n          operation;\n      for (var i = 0; i < changes.length; i++) {\n        change = changes[i];\n        if (change.added) {\n          operation = 1;\n        } else if (change.removed) {\n          operation = -1;\n        } else {\n          operation = 0;\n        }\n\n        ret.push([operation, change.value]);\n      }\n      return ret;\n    },\n\n    canonicalize: canonicalize\n  };\n\n  /*istanbul ignore next */\n  /*global module */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = JsDiff;\n  } else if (typeof define === 'function' && define.amd) {\n    /*global define */\n    define([], function() { return JsDiff; });\n  } else if (typeof global.JsDiff === 'undefined') {\n    global.JsDiff = JsDiff;\n  }\n}(this));\n\n},{}],68:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n	if (typeof str !== 'string') {\n		throw new TypeError('Expected a string');\n	}\n\n	return str.replace(matchOperatorsRe,  '\\\\$&');\n};\n\n},{}],69:[function(require,module,exports){\n(function (process){\n// Growl - Copyright TJ Holowaychuk <tj@vision-media.ca> (MIT Licensed)\n\n/**\n * Module dependencies.\n */\n\nvar exec = require('child_process').exec\n  , fs = require('fs')\n  , path = require('path')\n  , exists = fs.existsSync || path.existsSync\n  , os = require('os')\n  , quote = JSON.stringify\n  , cmd;\n\nfunction which(name) {\n  var paths = process.env.PATH.split(':');\n  var loc;\n  \n  for (var i = 0, len = paths.length; i < len; ++i) {\n    loc = path.join(paths[i], name);\n    if (exists(loc)) return loc;\n  }\n}\n\nswitch(os.type()) {\n  case 'Darwin':\n    if (which('terminal-notifier')) {\n      cmd = {\n          type: \"Darwin-NotificationCenter\"\n        , pkg: \"terminal-notifier\"\n        , msg: '-message'\n        , title: '-title'\n        , subtitle: '-subtitle'\n        , priority: {\n              cmd: '-execute'\n            , range: []\n          }\n      };\n    } else {\n      cmd = {\n          type: \"Darwin-Growl\"\n        , pkg: \"growlnotify\"\n        , msg: '-m'\n        , sticky: '--sticky'\n        , priority: {\n              cmd: '--priority'\n            , range: [\n                -2\n              , -1\n              , 0\n              , 1\n              , 2\n              , \"Very Low\"\n              , \"Moderate\"\n              , \"Normal\"\n              , \"High\"\n              , \"Emergency\"\n            ]\n          }\n      };\n    }\n    break;\n  case 'Linux':\n    cmd = {\n        type: \"Linux\"\n      , pkg: \"notify-send\"\n      , msg: ''\n      , sticky: '-t 0'\n      , icon: '-i'\n      , priority: {\n          cmd: '-u'\n        , range: [\n            \"low\"\n          , \"normal\"\n          , \"critical\"\n        ]\n      }\n    };\n    break;\n  case 'Windows_NT':\n    cmd = {\n        type: \"Windows\"\n      , pkg: \"growlnotify\"\n      , msg: ''\n      , sticky: '/s:true'\n      , title: '/t:'\n      , icon: '/i:'\n      , priority: {\n            cmd: '/p:'\n          , range: [\n              -2\n            , -1\n            , 0\n            , 1\n            , 2\n          ]\n        }\n    };\n    break;\n}\n\n/**\n * Expose `growl`.\n */\n\nexports = module.exports = growl;\n\n/**\n * Node-growl version.\n */\n\nexports.version = '1.4.1'\n\n/**\n * Send growl notification _msg_ with _options_.\n *\n * Options:\n *\n *  - title   Notification title\n *  - sticky  Make the notification stick (defaults to false)\n *  - priority  Specify an int or named key (default is 0)\n *  - name    Application name (defaults to growlnotify)\n *  - image\n *    - path to an icon sets --iconpath\n *    - path to an image sets --image\n *    - capitalized word sets --appIcon\n *    - filename uses extname as --icon\n *    - otherwise treated as --icon\n *\n * Examples:\n *\n *   growl('New email')\n *   growl('5 new emails', { title: 'Thunderbird' })\n *   growl('Email sent', function(){\n *     // ... notification sent\n *   })\n *\n * @param {string} msg\n * @param {object} options\n * @param {function} fn\n * @api public\n */\n\nfunction growl(msg, options, fn) {\n  var image\n    , args\n    , options = options || {}\n    , fn = fn || function(){};\n\n  // noop\n  if (!cmd) return fn(new Error('growl not supported on this platform'));\n  args = [cmd.pkg];\n\n  // image\n  if (image = options.image) {\n    switch(cmd.type) {\n      case 'Darwin-Growl':\n        var flag, ext = path.extname(image).substr(1)\n        flag = flag || ext == 'icns' && 'iconpath'\n        flag = flag || /^[A-Z]/.test(image) && 'appIcon'\n        flag = flag || /^png|gif|jpe?g$/.test(ext) && 'image'\n        flag = flag || ext && (image = ext) && 'icon'\n        flag = flag || 'icon'\n        args.push('--' + flag, quote(image))\n        break;\n      case 'Linux':\n        args.push(cmd.icon, quote(image));\n        // libnotify defaults to sticky, set a hint for transient notifications\n        if (!options.sticky) args.push('--hint=int:transient:1');\n        break;\n      case 'Windows':\n        args.push(cmd.icon + quote(image));\n        break;\n    }\n  }\n\n  // sticky\n  if (options.sticky) args.push(cmd.sticky);\n\n  // priority\n  if (options.priority) {\n    var priority = options.priority + '';\n    var checkindexOf = cmd.priority.range.indexOf(priority);\n    if (~cmd.priority.range.indexOf(priority)) {\n      args.push(cmd.priority, options.priority);\n    }\n  }\n\n  // name\n  if (options.name && cmd.type === \"Darwin-Growl\") {\n    args.push('--name', options.name);\n  }\n\n  switch(cmd.type) {\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Darwin-NotificationCenter':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) {\n        args.push(cmd.title);\n        args.push(quote(options.title));\n      }\n      if (options.subtitle) {\n        args.push(cmd.subtitle);\n        args.push(quote(options.subtitle));\n      }\n      break;\n    case 'Darwin-Growl':\n      args.push(cmd.msg);\n      args.push(quote(msg));\n      if (options.title) args.push(quote(options.title));\n      break;\n    case 'Linux':\n      if (options.title) {\n        args.push(quote(options.title));\n        args.push(cmd.msg);\n        args.push(quote(msg));\n      } else {\n        args.push(quote(msg));\n      }\n      break;\n    case 'Windows':\n      args.push(quote(msg));\n      if (options.title) args.push(cmd.title + quote(options.title));\n      break;\n  }\n\n  // execute\n  exec(args.join(' '), fn);\n};\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"child_process\":41,\"fs\":41,\"os\":50,\"path\":41}],70:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":51,\"fs\":41,\"path\":41}],71:[function(require,module,exports){\n(function (process,global){\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')();\n\nvar Mocha = require('../');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function(e, fn){\n  if ('uncaughtException' == e) {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function() {};\n    }\n    var i = Mocha.utils.indexOf(uncaughtExceptionHandlers, fn);\n    if (i != -1) { uncaughtExceptionHandlers.splice(i, 1); }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function(e, fn){\n  if ('uncaughtException' == e) {\n    global.onerror = function(err, url, line){\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = []\n  , immediateTimeout;\n\nfunction timeslice() {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function(callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function(err) {\n  Mocha.utils.forEach(uncaughtExceptionHandlers, function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function(ui){\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function(opts){\n  if ('string' == typeof opts) opts = { ui: opts };\n  for (var opt in opts) this[opt](opts[opt]);\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function(fn){\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) mocha.grep(new RegExp(query.grep));\n  if (query.fgrep) mocha.grep(query.fgrep);\n  if (query.invert) mocha.invert();\n\n  return Mocha.prototype.run.call(mocha, function(err){\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) fn(err);\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../\":1,\"_process\":51,\"browser-stdout\":40}]},{},[71]);\n";
},function(n,e,t){var r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";!function(n){"use strict";function e(n){var e=n.charCodeAt(0);return e===s||e===c?62:e===a||e===h?63:u>e?-1:u+10>e?e-u+26+26:f+26>e?e-f:l+26>e?e-l+26:void 0}function t(n){function t(n){l[c++]=n}var r,i,s,a,u,l;if(n.length%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var f=n.length;u="="===n.charAt(f-2)?2:"="===n.charAt(f-1)?1:0,l=new o(3*n.length/4-u),s=u>0?n.length-4:n.length;var c=0;for(r=0,i=0;s>r;r+=4,i+=3)a=e(n.charAt(r))<<18|e(n.charAt(r+1))<<12|e(n.charAt(r+2))<<6|e(n.charAt(r+3)),t((16711680&a)>>16),t((65280&a)>>8),t(255&a);return 2===u?(a=e(n.charAt(r))<<2|e(n.charAt(r+1))>>4,t(255&a)):1===u&&(a=e(n.charAt(r))<<10|e(n.charAt(r+1))<<4|e(n.charAt(r+2))>>2,t(a>>8&255),t(255&a)),l}function i(n){function e(n){return r.charAt(n)}function t(n){return e(n>>18&63)+e(n>>12&63)+e(n>>6&63)+e(63&n)}var i,o,s,a=n.length%3,u="";for(i=0,s=n.length-a;s>i;i+=3)o=(n[i]<<16)+(n[i+1]<<8)+n[i+2],u+=t(o);switch(a){case 1:o=n[n.length-1],u+=e(o>>2),u+=e(o<<4&63),u+="==";break;case 2:o=(n[n.length-2]<<8)+n[n.length-1],u+=e(o>>10),u+=e(o>>4&63),u+=e(o<<2&63),u+="="}return u}var o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="+".charCodeAt(0),a="/".charCodeAt(0),u="0".charCodeAt(0),l="a".charCodeAt(0),f="A".charCodeAt(0),c="-".charCodeAt(0),h="_".charCodeAt(0);n.toByteArray=t,n.fromByteArray=i}(e)},function(n,e){e.read=function(n,e,t,r,i){var o,s,a=8*i-r-1,u=(1<<a)-1,l=u>>1,f=-7,c=t?i-1:0,h=t?-1:1,p=n[e+c];for(c+=h,o=p&(1<<-f)-1,p>>=-f,f+=a;f>0;o=256*o+n[e+c],c+=h,f-=8);for(s=o&(1<<-f)-1,o>>=-f,f+=r;f>0;s=256*s+n[e+c],c+=h,f-=8);if(0===o)o=1-l;else{if(o===u)return s?NaN:(p?-1:1)*(1/0);s+=Math.pow(2,r),o-=l}return(p?-1:1)*s*Math.pow(2,o-r)},e.write=function(n,e,t,r,i,o){var s,a,u,l=8*o-i-1,f=(1<<l)-1,c=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=r?0:o-1,d=r?1:-1,g=0>e||0===e&&0>1/e?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=f):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),e+=s+c>=1?h/u:h*Math.pow(2,1-c),e*u>=2&&(s++,u/=2),s+c>=f?(a=0,s=f):s+c>=1?(a=(e*u-1)*Math.pow(2,i),s+=c):(a=e*Math.pow(2,c-1)*Math.pow(2,i),s=0));i>=8;n[t+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,l+=i;l>0;n[t+p]=255&s,p+=d,s/=256,l-=8);n[t+p-d]|=128*g}},function(n,e){var t={}.toString;n.exports=Array.isArray||function(n){return"[object Array]"==t.call(n)}},function(n,e){function t(){l=!1,s.length?u=s.concat(u):f=-1,u.length&&r()}function r(){if(!l){var n=setTimeout(t);l=!0;for(var e=u.length;e;){for(s=u,u=[];++f<e;)s&&s[f].run();f=-1,e=u.length}s=null,l=!1,clearTimeout(n)}}function i(n,e){this.fun=n,this.array=e}function o(){}var s,a=n.exports={},u=[],l=!1,f=-1;a.nextTick=function(n){var e=new Array(arguments.length-1);if(arguments.length>1)for(var t=1;t<arguments.length;t++)e[t-1]=arguments[t];u.push(new i(n,e)),1!==u.length||l||setTimeout(r,0)},i.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=o,a.addListener=o,a.once=o,a.off=o,a.removeListener=o,a.removeAllListeners=o,a.emit=o,a.binding=function(n){throw new Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(n){throw new Error("process.chdir is not supported")},a.umask=function(){return 0}}]);